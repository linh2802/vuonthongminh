CCS PCM C Compiler, Version 5.101, 43599               08-Jan-23 17:59

               Filename:   C:\Users\84834\Desktop\Doanmonhoc\Code1\Code\main.lst

               ROM used:   4311 words (53%)
                           Largest free fragment is 2048
               RAM used:   42 (11%) at main() level
                           74 (20%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   04C
002B:  MOVF   22,W
002C:  MOVWF  04
002D:  MOVF   23,W
002E:  MOVWF  77
002F:  MOVF   24,W
0030:  MOVWF  78
0031:  MOVF   25,W
0032:  MOVWF  79
0033:  MOVF   26,W
0034:  MOVWF  7A
0035:  MOVF   27,W
0036:  BSF    03.6
0037:  MOVWF  0D
0038:  BCF    03.6
0039:  MOVF   28,W
003A:  BSF    03.6
003B:  MOVWF  0F
003C:  BCF    03.6
003D:  MOVF   29,W
003E:  BSF    03.6
003F:  MOVWF  0C
0040:  BCF    03.6
0041:  MOVF   2A,W
0042:  BSF    03.6
0043:  MOVWF  0E
0044:  BCF    03.6
0045:  MOVF   20,W
0046:  MOVWF  0A
0047:  SWAPF  21,W
0048:  MOVWF  03
0049:  SWAPF  7F,F
004A:  SWAPF  7F,W
004B:  RETFIE
004C:  BCF    0A.3
004D:  BCF    0A.4
004E:  GOTO   4CB
.................... #include <16F877A.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
004F:  BCF    0A.0
0050:  BCF    0A.1
0051:  BCF    0A.2
0052:  ADDWF  02,F
0053:  RETLW  28
0054:  RETLW  0C
0055:  RETLW  01
0056:  RETLW  06
*
04DC:  DATA 20,10
04DD:  DATA C8,22
04DE:  DATA 20,2A
04DF:  DATA C8,27
04E0:  DATA CE,23
04E1:  DATA 20,2A
04E2:  DATA D5,27
04E3:  DATA 49,10
04E4:  DATA C3,20
04E5:  DATA 59,10
04E6:  DATA 00,00
04E7:  DATA 20,10
04E8:  DATA 20,10
04E9:  DATA 20,10
04EA:  DATA D4,2A
04EB:  DATA 20,22
04EC:  DATA 4F,27
04ED:  DATA 47,00
04EE:  DATA 20,10
04EF:  DATA 20,10
04F0:  DATA A0,29
04F1:  DATA 65,3A
04F2:  DATA 75,38
04F3:  DATA 20,10
04F4:  DATA A0,29
04F5:  DATA 65,37
04F6:  DATA F3,37
04F7:  DATA 72,00
04F8:  DATA D4,32
04F9:  DATA 6D,38
04FA:  DATA 3A,10
04FB:  DATA 00,01
04FC:  DATA C8,3A
04FD:  DATA ED,34
04FE:  DATA 3A,10
04FF:  DATA 00,01
0500:  DATA 43,10
0501:  DATA 20,10
0502:  DATA 20,00
0503:  DATA 25,10
0504:  DATA 20,10
0505:  DATA 20,10
0506:  DATA 00,01
0507:  DATA 25,10
0508:  DATA 00,01
0509:  DATA 20,10
050A:  DATA 20,10
050B:  DATA 20,10
050C:  DATA 20,10
050D:  DATA 20,10
050E:  DATA 20,10
050F:  DATA 20,10
0510:  DATA 20,10
0511:  DATA 20,10
0512:  DATA 20,10
0513:  DATA 00,01
0514:  DATA 4E,34
0515:  DATA 61,37
0516:  DATA 20,37
0517:  DATA 75,3A
0518:  DATA A0,26
0519:  DATA 41,26
051A:  DATA 20,10
051B:  DATA 20,10
051C:  DATA 20,10
051D:  DATA 00,01
051E:  DATA E4,32
051F:  DATA 20,31
0520:  DATA 61,3A
0521:  DATA 2F,3A
0522:  DATA 61,3A
0523:  DATA A0,36
0524:  DATA E1,3C
0525:  DATA 20,31
0526:  DATA EF,36
0527:  DATA 00,01
0528:  DATA CD,30
0529:  DATA 79,10
052A:  DATA E2,37
052B:  DATA 6D,10
052C:  DATA E2,30
052D:  DATA 74,00
052E:  DATA CD,30
052F:  DATA 79,10
0530:  DATA E2,37
0531:  DATA 6D,10
0532:  DATA F4,30
0533:  DATA 74,00
0534:  DATA C3,30
0535:  DATA 69,10
0536:  DATA CD,3A
0537:  DATA 63,10
0538:  DATA 4E,34
0539:  DATA E9,32
053A:  DATA 74,10
053B:  DATA C4,37
053C:  DATA 20,10
053D:  DATA 00,01
053E:  DATA D4,32
053F:  DATA 6D,38
0540:  DATA 3A,10
0541:  DATA 25,18
0542:  DATA 32,32
0543:  DATA 00,00
0544:  DATA 43,10
0545:  DATA 20,10
0546:  DATA 00,01
0547:  DATA 20,10
0548:  DATA 20,10
0549:  DATA 20,10
054A:  DATA 00,01
054B:  DATA 20,10
054C:  DATA 20,10
054D:  DATA 20,10
054E:  DATA 20,10
054F:  DATA 20,10
0550:  DATA 20,10
0551:  DATA 20,10
0552:  DATA 20,10
0553:  DATA 20,10
0554:  DATA 20,10
0555:  DATA 00,01
0556:  DATA 20,10
0557:  DATA 20,10
0558:  DATA 20,10
0559:  DATA 20,10
055A:  DATA 20,10
055B:  DATA 20,10
055C:  DATA 20,10
055D:  DATA 20,10
055E:  DATA 20,10
055F:  DATA 20,10
0560:  DATA 00,01
0561:  DATA C3,30
0562:  DATA 69,10
0563:  DATA CD,3A
0564:  DATA 63,10
0565:  DATA C4,37
0566:  DATA A0,20
0567:  DATA 6D,10
0568:  DATA 20,10
0569:  DATA 20,10
056A:  DATA 20,00
056B:  DATA C8,3A
056C:  DATA ED,34
056D:  DATA 3A,10
056E:  DATA 25,18
056F:  DATA 32,32
0570:  DATA 00,01
0571:  DATA 25,10
0572:  DATA 00,01
0573:  DATA D4,24
0574:  DATA CD,22
0575:  DATA 3A,10
0576:  DATA 25,18
0577:  DATA B2,3A
0578:  DATA BA,12
0579:  DATA 30,19
057A:  DATA 75,1D
057B:  DATA 25,18
057C:  DATA B2,3A
057D:  DATA 00,01
057E:  DATA C4,20
057F:  DATA D4,22
0580:  DATA 3A,10
0581:  DATA 25,18
0582:  DATA B2,3A
0583:  DATA AF,12
0584:  DATA 30,19
0585:  DATA F5,17
0586:  DATA 32,18
0587:  DATA 25,18
0588:  DATA B2,3A
0589:  DATA 00,01
058A:  DATA CD,30
058B:  DATA 6C,10
058C:  DATA E4,32
058D:  DATA 20,3A
058E:  DATA 61,3A
058F:  DATA AF,36
0590:  DATA 6F,10
0591:  DATA E4,32
0592:  DATA 6E,00
0593:  DATA CD,30
0594:  DATA 79,10
0595:  DATA E2,37
0596:  DATA 6D,10
0597:  DATA E2,30
0598:  DATA 74,00
0599:  DATA CD,30
059A:  DATA 79,10
059B:  DATA E2,37
059C:  DATA 6D,10
059D:  DATA F4,30
059E:  DATA 74,00
*
0750:  MOVF   0B,W
0751:  MOVWF  46
0752:  BCF    0B.7
0753:  BSF    03.5
0754:  BSF    03.6
0755:  BSF    0C.7
0756:  BSF    0C.0
0757:  NOP
0758:  NOP
0759:  BCF    03.5
075A:  BCF    03.6
075B:  BTFSC  46.7
075C:  BSF    0B.7
075D:  BSF    03.6
075E:  MOVF   0C,W
075F:  ANDLW  7F
0760:  BTFSC  03.2
0761:  GOTO   7B0
0762:  BCF    03.6
0763:  MOVWF  46
0764:  BSF    03.6
0765:  MOVF   0D,W
0766:  BCF    03.6
0767:  MOVWF  47
0768:  BSF    03.6
0769:  MOVF   0F,W
076A:  BCF    03.6
076B:  MOVWF  48
076C:  CLRF   2B
076D:  BTFSC  0B.7
076E:  BSF    2B.7
076F:  BCF    0B.7
0770:  MOVF   46,W
0771:  MOVWF  5A
0772:  CALL   195
0773:  BTFSC  2B.7
0774:  BSF    0B.7
0775:  MOVF   47,W
0776:  BSF    03.6
0777:  MOVWF  0D
0778:  BCF    03.6
0779:  MOVF   48,W
077A:  BSF    03.6
077B:  MOVWF  0F
077C:  BCF    03.6
077D:  MOVF   0B,W
077E:  MOVWF  49
077F:  BCF    0B.7
0780:  BSF    03.5
0781:  BSF    03.6
0782:  BSF    0C.7
0783:  BSF    0C.0
0784:  NOP
0785:  NOP
0786:  BCF    03.5
0787:  BCF    03.6
0788:  BTFSC  49.7
0789:  BSF    0B.7
078A:  BSF    03.6
078B:  RLF    0C,W
078C:  RLF    0E,W
078D:  ANDLW  7F
078E:  BTFSC  03.2
078F:  GOTO   7B0
0790:  BCF    03.6
0791:  MOVWF  46
0792:  BSF    03.6
0793:  MOVF   0D,W
0794:  BCF    03.6
0795:  MOVWF  47
0796:  BSF    03.6
0797:  MOVF   0F,W
0798:  BCF    03.6
0799:  MOVWF  48
079A:  CLRF   2B
079B:  BTFSC  0B.7
079C:  BSF    2B.7
079D:  BCF    0B.7
079E:  MOVF   46,W
079F:  MOVWF  5A
07A0:  CALL   195
07A1:  BTFSC  2B.7
07A2:  BSF    0B.7
07A3:  MOVF   47,W
07A4:  BSF    03.6
07A5:  MOVWF  0D
07A6:  BCF    03.6
07A7:  MOVF   48,W
07A8:  BSF    03.6
07A9:  MOVWF  0F
07AA:  INCF   0D,F
07AB:  BTFSC  03.2
07AC:  INCF   0F,F
07AD:  BCF    03.6
07AE:  GOTO   750
07AF:  BSF    03.6
07B0:  BCF    03.6
07B1:  RETURN
*
07CE:  MOVF   49,W
07CF:  CLRF   78
07D0:  SUBWF  48,W
07D1:  BTFSC  03.0
07D2:  GOTO   7D6
07D3:  MOVF   48,W
07D4:  MOVWF  77
07D5:  GOTO   7E2
07D6:  CLRF   77
07D7:  MOVLW  08
07D8:  MOVWF  4A
07D9:  RLF    48,F
07DA:  RLF    77,F
07DB:  MOVF   49,W
07DC:  SUBWF  77,W
07DD:  BTFSC  03.0
07DE:  MOVWF  77
07DF:  RLF    78,F
07E0:  DECFSZ 4A,F
07E1:  GOTO   7D9
07E2:  RETURN
*
0804:  MOVLW  8E
0805:  MOVWF  77
0806:  MOVF   49,W
0807:  MOVWF  78
0808:  MOVF   48,W
0809:  MOVWF  79
080A:  CLRF   7A
080B:  MOVF   78,F
080C:  BTFSS  03.2
080D:  GOTO   018
080E:  MOVF   79,W
080F:  MOVWF  78
0810:  CLRF   79
0811:  MOVLW  08
0812:  SUBWF  77,F
0813:  MOVF   78,F
0814:  BTFSS  03.2
0815:  GOTO   018
0816:  CLRF   77
0817:  GOTO   020
0818:  BCF    03.0
0819:  BTFSC  78.7
081A:  GOTO   01F
081B:  RLF    79,F
081C:  RLF    78,F
081D:  DECF   77,F
081E:  GOTO   018
081F:  BCF    78.7
*
0836:  MOVF   4C,W
0837:  BTFSC  03.2
0838:  GOTO   0A7
0839:  MOVWF  54
083A:  MOVF   50,W
083B:  BTFSC  03.2
083C:  GOTO   0A7
083D:  ADDWF  54,F
083E:  BTFSS  03.0
083F:  GOTO   041
0840:  GOTO   048
0841:  MOVLW  7F
0842:  SUBWF  54,F
0843:  BTFSS  03.0
0844:  GOTO   0A7
0845:  BTFSC  03.2
0846:  GOTO   0A7
0847:  GOTO   04C
0848:  MOVLW  81
0849:  ADDWF  54,F
084A:  BTFSC  03.0
084B:  GOTO   0A7
084C:  MOVF   54,W
084D:  MOVWF  77
084E:  CLRF   78
084F:  CLRF   79
0850:  CLRF   7A
0851:  MOVF   4D,W
0852:  MOVWF  58
0853:  BSF    58.7
0854:  MOVF   4E,W
0855:  MOVWF  57
0856:  MOVF   4F,W
0857:  MOVWF  56
0858:  MOVLW  18
0859:  MOVWF  54
085A:  CLRF   55
085B:  BTFSS  56.0
085C:  GOTO   075
085D:  MOVF   53,W
085E:  ADDWF  7A,F
085F:  BTFSS  03.0
0860:  GOTO   067
0861:  INCF   79,F
0862:  BTFSS  03.2
0863:  GOTO   067
0864:  INCF   78,F
0865:  BTFSC  03.2
0866:  BSF    55.7
0867:  MOVF   52,W
0868:  ADDWF  79,F
0869:  BTFSS  03.0
086A:  GOTO   06E
086B:  INCF   78,F
086C:  BTFSC  03.2
086D:  BSF    55.7
086E:  MOVF   51,W
086F:  MOVWF  4E
0870:  BSF    4E.7
0871:  MOVF   4E,W
0872:  ADDWF  78,F
0873:  BTFSC  03.0
0874:  BSF    55.7
0875:  RLF    55,F
0876:  RRF    78,F
0877:  RRF    79,F
0878:  RRF    7A,F
0879:  RRF    58,F
087A:  RRF    57,F
087B:  RRF    56,F
087C:  BCF    03.0
087D:  DECFSZ 54,F
087E:  GOTO   05A
087F:  MOVLW  01
0880:  ADDWF  77,F
0881:  BTFSC  03.0
0882:  GOTO   0A7
0883:  BTFSC  78.7
0884:  GOTO   08C
0885:  RLF    58,F
0886:  RLF    7A,F
0887:  RLF    79,F
0888:  RLF    78,F
0889:  DECF   77,F
088A:  BTFSC  03.2
088B:  GOTO   0A7
088C:  BTFSS  58.7
088D:  GOTO   09D
088E:  INCF   7A,F
088F:  BTFSS  03.2
0890:  GOTO   09D
0891:  INCF   79,F
0892:  BTFSS  03.2
0893:  GOTO   09D
0894:  INCF   78,F
0895:  BTFSS  03.2
0896:  GOTO   09D
0897:  RRF    78,F
0898:  RRF    79,F
0899:  RRF    7A,F
089A:  INCF   77,F
089B:  BTFSC  03.2
089C:  GOTO   0A7
089D:  MOVF   4D,W
089E:  MOVWF  55
089F:  MOVF   51,W
08A0:  XORWF  55,F
08A1:  BTFSS  55.7
08A2:  GOTO   0A5
08A3:  BSF    78.7
08A4:  GOTO   0AB
08A5:  BCF    78.7
08A6:  GOTO   0AB
08A7:  CLRF   77
08A8:  CLRF   78
08A9:  CLRF   79
08AA:  CLRF   7A
*
08C2:  MOVF   4C,W
08C3:  BTFSC  03.2
08C4:  GOTO   188
08C5:  MOVWF  58
08C6:  MOVF   50,W
08C7:  BTFSC  03.2
08C8:  GOTO   188
08C9:  SUBWF  58,F
08CA:  BTFSC  03.0
08CB:  GOTO   0CD
08CC:  GOTO   0D2
08CD:  MOVLW  7F
08CE:  ADDWF  58,F
08CF:  BTFSC  03.0
08D0:  GOTO   188
08D1:  GOTO   0D8
08D2:  MOVLW  81
08D3:  SUBWF  58,F
08D4:  BTFSS  03.0
08D5:  GOTO   188
08D6:  BTFSC  03.2
08D7:  GOTO   188
08D8:  MOVF   58,W
08D9:  MOVWF  77
08DA:  CLRF   78
08DB:  CLRF   79
08DC:  CLRF   7A
08DD:  CLRF   57
08DE:  MOVF   4D,W
08DF:  MOVWF  56
08E0:  BSF    56.7
08E1:  MOVF   4E,W
08E2:  MOVWF  55
08E3:  MOVF   4F,W
08E4:  MOVWF  54
08E5:  MOVLW  19
08E6:  MOVWF  58
08E7:  MOVF   53,W
08E8:  SUBWF  54,F
08E9:  BTFSC  03.0
08EA:  GOTO   0FB
08EB:  MOVLW  01
08EC:  SUBWF  55,F
08ED:  BTFSC  03.0
08EE:  GOTO   0FB
08EF:  SUBWF  56,F
08F0:  BTFSC  03.0
08F1:  GOTO   0FB
08F2:  SUBWF  57,F
08F3:  BTFSC  03.0
08F4:  GOTO   0FB
08F5:  INCF   57,F
08F6:  INCF   56,F
08F7:  INCF   55,F
08F8:  MOVF   53,W
08F9:  ADDWF  54,F
08FA:  GOTO   12D
08FB:  MOVF   52,W
08FC:  SUBWF  55,F
08FD:  BTFSC  03.0
08FE:  GOTO   116
08FF:  MOVLW  01
0900:  SUBWF  56,F
0901:  BTFSC  03.0
0902:  GOTO   116
0903:  SUBWF  57,F
0904:  BTFSC  03.0
0905:  GOTO   116
0906:  INCF   57,F
0907:  INCF   56,F
0908:  MOVF   52,W
0909:  ADDWF  55,F
090A:  MOVF   53,W
090B:  ADDWF  54,F
090C:  BTFSS  03.0
090D:  GOTO   12D
090E:  INCF   55,F
090F:  BTFSS  03.2
0910:  GOTO   12D
0911:  INCF   56,F
0912:  BTFSS  03.2
0913:  GOTO   12D
0914:  INCF   57,F
0915:  GOTO   12D
0916:  MOVF   51,W
0917:  IORLW  80
0918:  SUBWF  56,F
0919:  BTFSC  03.0
091A:  GOTO   12C
091B:  MOVLW  01
091C:  SUBWF  57,F
091D:  BTFSC  03.0
091E:  GOTO   12C
091F:  INCF   57,F
0920:  MOVF   51,W
0921:  IORLW  80
0922:  ADDWF  56,F
0923:  MOVF   52,W
0924:  ADDWF  55,F
0925:  BTFSS  03.0
0926:  GOTO   10A
0927:  INCF   56,F
0928:  BTFSS  03.2
0929:  GOTO   10A
092A:  INCF   57,F
092B:  GOTO   10A
092C:  BSF    7A.0
092D:  DECFSZ 58,F
092E:  GOTO   130
092F:  GOTO   13B
0930:  BCF    03.0
0931:  RLF    54,F
0932:  RLF    55,F
0933:  RLF    56,F
0934:  RLF    57,F
0935:  BCF    03.0
0936:  RLF    7A,F
0937:  RLF    79,F
0938:  RLF    78,F
0939:  RLF    59,F
093A:  GOTO   0E7
093B:  BTFSS  59.0
093C:  GOTO   143
093D:  BCF    03.0
093E:  RRF    78,F
093F:  RRF    79,F
0940:  RRF    7A,F
0941:  RRF    59,F
0942:  GOTO   146
0943:  DECF   77,F
0944:  BTFSC  03.2
0945:  GOTO   188
0946:  BTFSC  59.7
0947:  GOTO   16F
0948:  BCF    03.0
0949:  RLF    54,F
094A:  RLF    55,F
094B:  RLF    56,F
094C:  RLF    57,F
094D:  MOVF   53,W
094E:  SUBWF  54,F
094F:  BTFSC  03.0
0950:  GOTO   15B
0951:  MOVLW  01
0952:  SUBWF  55,F
0953:  BTFSC  03.0
0954:  GOTO   15B
0955:  SUBWF  56,F
0956:  BTFSC  03.0
0957:  GOTO   15B
0958:  SUBWF  57,F
0959:  BTFSS  03.0
095A:  GOTO   17E
095B:  MOVF   52,W
095C:  SUBWF  55,F
095D:  BTFSC  03.0
095E:  GOTO   166
095F:  MOVLW  01
0960:  SUBWF  56,F
0961:  BTFSC  03.0
0962:  GOTO   166
0963:  SUBWF  57,F
0964:  BTFSS  03.0
0965:  GOTO   17E
0966:  MOVF   51,W
0967:  IORLW  80
0968:  SUBWF  56,F
0969:  BTFSC  03.0
096A:  GOTO   16F
096B:  MOVLW  01
096C:  SUBWF  57,F
096D:  BTFSS  03.0
096E:  GOTO   17E
096F:  INCF   7A,F
0970:  BTFSS  03.2
0971:  GOTO   17E
0972:  INCF   79,F
0973:  BTFSS  03.2
0974:  GOTO   17E
0975:  INCF   78,F
0976:  BTFSS  03.2
0977:  GOTO   17E
0978:  INCF   77,F
0979:  BTFSC  03.2
097A:  GOTO   188
097B:  RRF    78,F
097C:  RRF    79,F
097D:  RRF    7A,F
097E:  MOVF   4D,W
097F:  MOVWF  58
0980:  MOVF   51,W
0981:  XORWF  58,F
0982:  BTFSS  58.7
0983:  GOTO   186
0984:  BSF    78.7
0985:  GOTO   18C
0986:  BCF    78.7
0987:  GOTO   18C
0988:  CLRF   77
0989:  CLRF   78
098A:  CLRF   79
098B:  CLRF   7A
*
099C:  MOVLW  8E
099D:  MOVWF  77
099E:  MOVF   48,W
099F:  SUBWF  77,F
09A0:  MOVF   49,W
09A1:  MOVWF  79
09A2:  MOVF   4A,W
09A3:  MOVWF  78
09A4:  BSF    79.7
09A5:  MOVF   77,F
09A6:  BTFSC  03.2
09A7:  GOTO   1B3
09A8:  BCF    03.0
09A9:  MOVF   79,F
09AA:  BTFSS  03.2
09AB:  GOTO   1AF
09AC:  MOVF   78,F
09AD:  BTFSC  03.2
09AE:  GOTO   1B3
09AF:  RRF    79,F
09B0:  RRF    78,F
09B1:  DECFSZ 77,F
09B2:  GOTO   1A8
09B3:  BTFSS  49.7
09B4:  GOTO   1BA
09B5:  COMF   78,F
09B6:  COMF   79,F
09B7:  INCF   78,F
09B8:  BTFSC  03.2
09B9:  INCF   79,F
*
09D1:  MOVLW  20
09D2:  MOVWF  58
09D3:  CLRF   54
09D4:  CLRF   55
09D5:  CLRF   56
09D6:  CLRF   57
09D7:  MOVF   4F,W
09D8:  MOVWF  7A
09D9:  MOVF   4E,W
09DA:  MOVWF  79
09DB:  MOVF   4D,W
09DC:  MOVWF  78
09DD:  MOVF   4C,W
09DE:  MOVWF  77
09DF:  BCF    03.0
09E0:  BTFSS  77.0
09E1:  GOTO   1F0
09E2:  MOVF   50,W
09E3:  ADDWF  54,F
09E4:  MOVF   51,W
09E5:  BTFSC  03.0
09E6:  INCFSZ 51,W
09E7:  ADDWF  55,F
09E8:  MOVF   52,W
09E9:  BTFSC  03.0
09EA:  INCFSZ 52,W
09EB:  ADDWF  56,F
09EC:  MOVF   53,W
09ED:  BTFSC  03.0
09EE:  INCFSZ 53,W
09EF:  ADDWF  57,F
09F0:  RRF    57,F
09F1:  RRF    56,F
09F2:  RRF    55,F
09F3:  RRF    54,F
09F4:  RRF    7A,F
09F5:  RRF    79,F
09F6:  RRF    78,F
09F7:  RRF    77,F
09F8:  DECFSZ 58,F
09F9:  GOTO   1DF
*
0A11:  BTFSC  03.1
0A12:  GOTO   216
0A13:  MOVLW  54
0A14:  MOVWF  04
0A15:  BCF    03.7
0A16:  CLRF   77
0A17:  CLRF   78
0A18:  CLRF   79
0A19:  CLRF   7A
0A1A:  CLRF   54
0A1B:  CLRF   55
0A1C:  CLRF   56
0A1D:  CLRF   57
0A1E:  MOVF   53,W
0A1F:  IORWF  52,W
0A20:  IORWF  51,W
0A21:  IORWF  50,W
0A22:  BTFSC  03.2
0A23:  GOTO   254
0A24:  MOVLW  20
0A25:  MOVWF  58
0A26:  BCF    03.0
0A27:  RLF    4C,F
0A28:  RLF    4D,F
0A29:  RLF    4E,F
0A2A:  RLF    4F,F
0A2B:  RLF    54,F
0A2C:  RLF    55,F
0A2D:  RLF    56,F
0A2E:  RLF    57,F
0A2F:  MOVF   53,W
0A30:  SUBWF  57,W
0A31:  BTFSS  03.2
0A32:  GOTO   23D
0A33:  MOVF   52,W
0A34:  SUBWF  56,W
0A35:  BTFSS  03.2
0A36:  GOTO   23D
0A37:  MOVF   51,W
0A38:  SUBWF  55,W
0A39:  BTFSS  03.2
0A3A:  GOTO   23D
0A3B:  MOVF   50,W
0A3C:  SUBWF  54,W
0A3D:  BTFSS  03.0
0A3E:  GOTO   24E
0A3F:  MOVF   50,W
0A40:  SUBWF  54,F
0A41:  MOVF   51,W
0A42:  BTFSS  03.0
0A43:  INCFSZ 51,W
0A44:  SUBWF  55,F
0A45:  MOVF   52,W
0A46:  BTFSS  03.0
0A47:  INCFSZ 52,W
0A48:  SUBWF  56,F
0A49:  MOVF   53,W
0A4A:  BTFSS  03.0
0A4B:  INCFSZ 53,W
0A4C:  SUBWF  57,F
0A4D:  BSF    03.0
0A4E:  RLF    77,F
0A4F:  RLF    78,F
0A50:  RLF    79,F
0A51:  RLF    7A,F
0A52:  DECFSZ 58,F
0A53:  GOTO   226
0A54:  MOVF   54,W
0A55:  MOVWF  00
0A56:  INCF   04,F
0A57:  MOVF   55,W
0A58:  MOVWF  00
0A59:  INCF   04,F
0A5A:  MOVF   56,W
0A5B:  MOVWF  00
0A5C:  INCF   04,F
0A5D:  MOVF   57,W
0A5E:  MOVWF  00
*
0A6C:  MOVLW  20
0A6D:  BTFSS  43.4
0A6E:  MOVLW  30
0A6F:  MOVWF  44
0A70:  MOVF   42,W
0A71:  MOVWF  77
0A72:  BTFSS  42.7
0A73:  GOTO   27C
0A74:  COMF   77,F
0A75:  INCF   77,F
0A76:  MOVF   77,W
0A77:  MOVWF  42
0A78:  MOVLW  2D
0A79:  MOVWF  44
0A7A:  BSF    43.7
0A7B:  BSF    43.0
0A7C:  MOVF   42,W
0A7D:  MOVWF  48
0A7E:  MOVLW  64
0A7F:  MOVWF  49
0A80:  BCF    0A.3
0A81:  CALL   7CE
0A82:  BSF    0A.3
0A83:  MOVF   77,W
0A84:  MOVWF  42
0A85:  MOVLW  30
0A86:  ADDWF  78,W
0A87:  MOVWF  45
0A88:  MOVF   42,W
0A89:  MOVWF  48
0A8A:  MOVLW  0A
0A8B:  MOVWF  49
0A8C:  BCF    0A.3
0A8D:  CALL   7CE
0A8E:  BSF    0A.3
0A8F:  MOVLW  30
0A90:  ADDWF  77,W
0A91:  MOVWF  47
0A92:  MOVLW  30
0A93:  ADDWF  78,W
0A94:  MOVWF  46
0A95:  MOVF   44,W
0A96:  MOVWF  77
0A97:  MOVLW  30
0A98:  SUBWF  45,W
0A99:  BTFSC  03.2
0A9A:  GOTO   29F
0A9B:  BSF    43.1
0A9C:  BTFSC  43.7
0A9D:  BSF    43.2
0A9E:  GOTO   2B3
0A9F:  BTFSC  43.2
0AA0:  GOTO   2B3
0AA1:  MOVF   44,W
0AA2:  MOVWF  45
0AA3:  BTFSC  43.1
0AA4:  GOTO   2AA
0AA5:  MOVLW  30
0AA6:  SUBWF  46,W
0AA7:  BTFSC  03.2
0AA8:  GOTO   2AD
0AA9:  BSF    43.0
0AAA:  BTFSC  43.7
0AAB:  BSF    43.1
0AAC:  GOTO   2B3
0AAD:  BTFSS  03.2
0AAE:  BSF    43.0
0AAF:  BTFSS  03.2
0AB0:  GOTO   2B3
0AB1:  MOVF   45,W
0AB2:  MOVWF  46
0AB3:  BTFSC  43.2
0AB4:  GOTO   2BA
0AB5:  BTFSC  43.1
0AB6:  GOTO   2C5
0AB7:  BTFSC  43.0
0AB8:  GOTO   2D0
0AB9:  GOTO   2DB
0ABA:  CLRF   2B
0ABB:  BTFSC  0B.7
0ABC:  BSF    2B.7
0ABD:  BCF    0B.7
0ABE:  MOVF   44,W
0ABF:  MOVWF  5A
0AC0:  BCF    0A.3
0AC1:  CALL   195
0AC2:  BSF    0A.3
0AC3:  BTFSC  2B.7
0AC4:  BSF    0B.7
0AC5:  CLRF   2B
0AC6:  BTFSC  0B.7
0AC7:  BSF    2B.7
0AC8:  BCF    0B.7
0AC9:  MOVF   45,W
0ACA:  MOVWF  5A
0ACB:  BCF    0A.3
0ACC:  CALL   195
0ACD:  BSF    0A.3
0ACE:  BTFSC  2B.7
0ACF:  BSF    0B.7
0AD0:  CLRF   2B
0AD1:  BTFSC  0B.7
0AD2:  BSF    2B.7
0AD3:  BCF    0B.7
0AD4:  MOVF   46,W
0AD5:  MOVWF  5A
0AD6:  BCF    0A.3
0AD7:  CALL   195
0AD8:  BSF    0A.3
0AD9:  BTFSC  2B.7
0ADA:  BSF    0B.7
0ADB:  CLRF   2B
0ADC:  BTFSC  0B.7
0ADD:  BSF    2B.7
0ADE:  BCF    0B.7
0ADF:  MOVF   47,W
0AE0:  MOVWF  5A
0AE1:  BCF    0A.3
0AE2:  CALL   195
0AE3:  BSF    0A.3
0AE4:  BTFSC  2B.7
0AE5:  BSF    0B.7
0AE6:  RETURN
*
0B27:  MOVF   0B,W
0B28:  MOVWF  46
0B29:  BCF    0B.7
0B2A:  BSF    03.5
0B2B:  BSF    03.6
0B2C:  BSF    0C.7
0B2D:  BSF    0C.0
0B2E:  NOP
0B2F:  NOP
0B30:  BCF    03.5
0B31:  BCF    03.6
0B32:  BTFSC  46.7
0B33:  BSF    0B.7
0B34:  BTFSC  03.0
0B35:  GOTO   366
0B36:  BSF    03.6
0B37:  MOVF   0C,W
0B38:  ANDLW  7F
0B39:  BCF    03.6
0B3A:  MOVWF  46
0B3B:  BSF    03.6
0B3C:  MOVF   0D,W
0B3D:  BCF    03.6
0B3E:  MOVWF  47
0B3F:  BSF    03.6
0B40:  MOVF   0F,W
0B41:  BCF    03.6
0B42:  MOVWF  48
0B43:  CLRF   2B
0B44:  BTFSC  0B.7
0B45:  BSF    2B.7
0B46:  BCF    0B.7
0B47:  MOVF   46,W
0B48:  MOVWF  5A
0B49:  BCF    0A.3
0B4A:  CALL   195
0B4B:  BSF    0A.3
0B4C:  BTFSC  2B.7
0B4D:  BSF    0B.7
0B4E:  MOVF   47,W
0B4F:  BSF    03.6
0B50:  MOVWF  0D
0B51:  BCF    03.6
0B52:  MOVF   48,W
0B53:  BSF    03.6
0B54:  MOVWF  0F
0B55:  BCF    03.6
0B56:  MOVF   0B,W
0B57:  MOVWF  49
0B58:  BCF    0B.7
0B59:  BSF    03.5
0B5A:  BSF    03.6
0B5B:  BSF    0C.7
0B5C:  BSF    0C.0
0B5D:  NOP
0B5E:  NOP
0B5F:  BCF    03.5
0B60:  BCF    03.6
0B61:  BTFSC  49.7
0B62:  BSF    0B.7
0B63:  DECFSZ 45,F
0B64:  GOTO   366
0B65:  GOTO   38D
0B66:  BSF    03.6
0B67:  RLF    0C,W
0B68:  RLF    0E,W
0B69:  ANDLW  7F
0B6A:  BCF    03.6
0B6B:  MOVWF  46
0B6C:  BSF    03.6
0B6D:  MOVF   0D,W
0B6E:  BCF    03.6
0B6F:  MOVWF  47
0B70:  BSF    03.6
0B71:  MOVF   0F,W
0B72:  BCF    03.6
0B73:  MOVWF  48
0B74:  CLRF   2B
0B75:  BTFSC  0B.7
0B76:  BSF    2B.7
0B77:  BCF    0B.7
0B78:  MOVF   46,W
0B79:  MOVWF  5A
0B7A:  BCF    0A.3
0B7B:  CALL   195
0B7C:  BSF    0A.3
0B7D:  BTFSC  2B.7
0B7E:  BSF    0B.7
0B7F:  MOVF   47,W
0B80:  BSF    03.6
0B81:  MOVWF  0D
0B82:  BCF    03.6
0B83:  MOVF   48,W
0B84:  BSF    03.6
0B85:  MOVWF  0F
0B86:  INCF   0D,F
0B87:  BTFSC  03.2
0B88:  INCF   0F,F
0B89:  BCF    03.0
0B8A:  BCF    03.6
0B8B:  DECFSZ 45,F
0B8C:  GOTO   327
0B8D:  RETURN
0B8E:  MOVF   78,W
0B8F:  MOVF   45,W
0B90:  MOVWF  48
0B91:  MOVLW  64
0B92:  MOVWF  49
0B93:  BCF    0A.3
0B94:  CALL   7CE
0B95:  BSF    0A.3
0B96:  MOVF   77,W
0B97:  MOVWF  45
0B98:  MOVF   78,W
0B99:  MOVLW  30
0B9A:  BTFSS  03.2
0B9B:  GOTO   3A3
0B9C:  BTFSS  46.1
0B9D:  GOTO   3B2
0B9E:  BTFSC  46.3
0B9F:  GOTO   3B2
0BA0:  BTFSC  46.4
0BA1:  MOVLW  20
0BA2:  GOTO   3A6
0BA3:  BCF    46.3
0BA4:  BCF    46.4
0BA5:  BSF    46.0
0BA6:  ADDWF  78,F
0BA7:  CLRF   2B
0BA8:  BTFSC  0B.7
0BA9:  BSF    2B.7
0BAA:  BCF    0B.7
0BAB:  MOVF   78,W
0BAC:  MOVWF  5A
0BAD:  BCF    0A.3
0BAE:  CALL   195
0BAF:  BSF    0A.3
0BB0:  BTFSC  2B.7
0BB1:  BSF    0B.7
0BB2:  MOVF   45,W
0BB3:  MOVWF  48
0BB4:  MOVLW  0A
0BB5:  MOVWF  49
0BB6:  BCF    0A.3
0BB7:  CALL   7CE
0BB8:  BSF    0A.3
0BB9:  MOVF   77,W
0BBA:  MOVWF  45
0BBB:  MOVF   78,W
0BBC:  MOVLW  30
0BBD:  BTFSS  03.2
0BBE:  GOTO   3C5
0BBF:  BTFSC  46.3
0BC0:  GOTO   3D1
0BC1:  BTFSS  46.0
0BC2:  GOTO   3D1
0BC3:  BTFSC  46.4
0BC4:  MOVLW  20
0BC5:  ADDWF  78,F
0BC6:  CLRF   2B
0BC7:  BTFSC  0B.7
0BC8:  BSF    2B.7
0BC9:  BCF    0B.7
0BCA:  MOVF   78,W
0BCB:  MOVWF  5A
0BCC:  BCF    0A.3
0BCD:  CALL   195
0BCE:  BSF    0A.3
0BCF:  BTFSC  2B.7
0BD0:  BSF    0B.7
0BD1:  MOVLW  30
0BD2:  ADDWF  45,F
0BD3:  CLRF   2B
0BD4:  BTFSC  0B.7
0BD5:  BSF    2B.7
0BD6:  BCF    0B.7
0BD7:  MOVF   45,W
0BD8:  MOVWF  5A
0BD9:  BCF    0A.3
0BDA:  CALL   195
0BDB:  BSF    0A.3
0BDC:  BTFSC  2B.7
0BDD:  BSF    0B.7
0BDE:  RETURN
*
150C:  BSF    0A.0
150D:  BCF    0A.1
150E:  BSF    0A.2
150F:  ADDWF  02,F
1510:  GOTO   0D3
1511:  GOTO   1B6
1512:  GOTO   246
1513:  GOTO   328
1514:  GOTO   3BD
.................... 
.................... #list
.................... 
.................... #device *=16 adc=10
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP
.................... #use delay(clock=4M)
.................... #use I2C(MASTER, I2C1, SLOW = 100000, STREAM = DS1307_STREAM)
.................... #include <lcd.h>
.................... #define _lcd_h_
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #use delay(clock=4000000)
*
0057:  MOVLW  5B
0058:  MOVWF  04
0059:  BCF    03.7
005A:  MOVF   00,W
005B:  BTFSC  03.2
005C:  GOTO   06B
005D:  MOVLW  01
005E:  MOVWF  78
005F:  CLRF   77
0060:  DECFSZ 77,F
0061:  GOTO   060
0062:  DECFSZ 78,F
0063:  GOTO   05F
0064:  MOVLW  4A
0065:  MOVWF  77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  GOTO   069
0069:  DECFSZ 00,F
006A:  GOTO   05D
006B:  RETURN
.................... void lcd_init(void);             // Ham dung de khoi dong C.LCD.
.................... byte lcd_read_byte(void);         // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... byte lcd_read_nibble(void);         // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
.................... void lcd_send_byte(byte address, byte n);   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... void lcd_send_nibble(byte n);      // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... void lcd_gotoxy(byte x, byte y);   // Ham thiet lap vi tri ghi tren C.LCD.
.................... char lcd_getc(byte x, byte y);      // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... void lcd_putc(char c);            // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... // Khai bao bien.
.................... // Dinh nghia cac thong so.
.................... #define LCD_RS_PIN         PIN_D0
.................... #define LCD_RW_PIN         PIN_D1
.................... #define LCD_ENABLE_PIN     PIN_D2
.................... #define LCD_DATA0          PIN_C0
.................... #define LCD_DATA1          PIN_C1
.................... #define LCD_DATA2          PIN_C2
.................... #define LCD_DATA3          PIN_C3
.................... #define LCD_DATA4          PIN_D3
.................... #define LCD_DATA5          PIN_D4
.................... #define LCD_DATA6          PIN_D5
.................... #define LCD_DATA7          PIN_D6
.................... /*
.................... #define LCD_RS_PIN            PIN_C5   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN         PIN_C6
.................... #define LCD_ENABLE_PIN     PIN_C7
.................... #define LCD_DATA4          PIN_D4
.................... #define LCD_DATA5          PIN_D5
.................... #define LCD_DATA6          PIN_D6
.................... #define LCD_DATA7          PIN_D7  
.................... */
.................... /*
.................... #define LCD_RS_PIN         PIN_D1   // Cac ket noi C.LCD voi vi dieu khien.
.................... #define LCD_RW_PIN      PIN_D2
.................... #define LCD_ENABLE_PIN  PIN_D3
.................... #define LCD_DATA4       PIN_D4
.................... #define LCD_DATA5       PIN_D5
.................... #define LCD_DATA6       PIN_D6
.................... #define LCD_DATA7       PIN_D7  
.................... */
.................... #define lcd_output_enable(x)   output_bit(LCD_ENABLE_PIN, x)   // Lenh dieu khien chan LCD_ENABLE_PIN.
.................... #define lcd_enable_tris()   output_drive(LCD_ENABLE_PIN)
.................... 
.................... #define lcd_output_rs(x)   output_bit(LCD_RS_PIN, x)   // Lenh dieu khien chan LCD_RS_PIN.
.................... #define lcd_rs_tris()      output_drive(LCD_RS_PIN)
.................... 
.................... #define lcd_output_rw(x)   output_bit(LCD_RW_PIN, x)   // Lenh dieu khien chan LCD_RW_PIN
.................... #define lcd_rw_tris()      output_drive(LCD_RW_PIN)
.................... 
.................... #define lcd_line_one   0x00    // Dia chi RAM C.LCD cho hang thu 1.
.................... #define lcd_line_two   0x40    // Dia chi RAM C.LCD cho hang thu 2.
.................... #define lcd_line_three   0x14
.................... #define lcd_line_four   0x54
.................... #define LCD_TYPE 0x02           // Thong tin cau hinh C.LCD: 0x00=5x7, 0x01=5x10, 0x02=2 lines
.................... 
.................... // Dinh nghia cac hang so.
.................... byte const LCD_INIT_STRING[4] = {0x28 | (LCD_TYPE << 2), 0x0C, 0x01, 0x06};
....................         // Cac byte nay can thiet de gui toi C.LCD, dung de khoi dong cau hinh hoat dong cho C.LCD.
....................       // Byte 1: 0x20 | (LCD_TYPE << 2) - So bit du lieu giao tiep (DL), so dong hien thi (N), kieu ky tu (F).
....................       //         0 0 1 DL N F x x (DL: Data Length, N: Number Line, F: Font).
....................          // Truong hop 1: 0x20 - 4 bit / 1 dong / 5 x 7.
....................          // Truong hop 2: 0x24 - 4 bit / 1 dong / 5 x 10.
....................          // Truong hop 3: 0x28 - 4 bit / 2 dong / 5 x 7.
....................       // Byte 2: 0x0C - Dieu khien hien thi (Bat hien thi, tat con tro, tat nhap nhay con tro).
....................       //         0 0 0 0 1 D C B (D: Display, C: Cursor, B: Blink).
....................       // Byte 3: 0x01 - Xoa hien thi va tra con tro ve dau dong.
....................       // Byte 4: 0x06 - Dat che do dau vao (Che do tang dia chi, tat dich chuyen hien thi).
....................       //         0 0 0 0 0 1 I/D S (I/D: Increment/Decrement, S: Shift).
....................       // Byte 5: .... - Doi con tro / hien thi.
....................       //         0 0 0 1 S/C R/L x x (S/C: Screen/Cursor, R/L: Right/Left).
.................... 
.................... // ***************************************************
.................... void lcd_init(void)    // Ham dung de khoi dong C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte i;
.................... // Dinh nghia ham.
.................... output_drive(LCD_DATA0);
*
059F:  BCF    2C.0
05A0:  MOVF   2C,W
05A1:  BSF    03.5
05A2:  MOVWF  07
.................... output_drive(LCD_DATA1);
05A3:  BCF    03.5
05A4:  BCF    2C.1
05A5:  MOVF   2C,W
05A6:  BSF    03.5
05A7:  MOVWF  07
.................... output_drive(LCD_DATA2);
05A8:  BCF    03.5
05A9:  BCF    2C.2
05AA:  MOVF   2C,W
05AB:  BSF    03.5
05AC:  MOVWF  07
.................... output_drive(LCD_DATA3);
05AD:  BCF    03.5
05AE:  BCF    2C.3
05AF:  MOVF   2C,W
05B0:  BSF    03.5
05B1:  MOVWF  07
.................... output_drive(LCD_DATA4);   // Thiet lap chan port (Data) o che do ngo ra.
05B2:  BCF    08.3
.................... output_drive(LCD_DATA5);
05B3:  BCF    08.4
.................... output_drive(LCD_DATA6);
05B4:  BCF    08.5
.................... output_drive(LCD_DATA7);
05B5:  BCF    08.6
.................... lcd_enable_tris();
05B6:  BCF    08.2
.................... output_drive(LCD_ENABLE_PIN);// Thiet lap chan port (Control: EN, RS, RW) o che do ngo ra.
05B7:  BCF    08.2
.................... lcd_rs_tris();
05B8:  BCF    08.0
.................... output_drive(LCD_RS_PIN);
05B9:  BCF    08.0
.................... lcd_rw_tris();
05BA:  BCF    08.1
.................... output_drive(LCD_RW_PIN);
05BB:  BCF    08.1
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
05BC:  BCF    03.5
05BD:  BCF    08.0
05BE:  BSF    03.5
05BF:  BCF    08.0
.................... lcd_output_rw(0);         // RW = 0 - Ghi thong tin vao C.LCD.
05C0:  BCF    03.5
05C1:  BCF    08.1
05C2:  BSF    03.5
05C3:  BCF    08.1
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
05C4:  BCF    03.5
05C5:  BCF    08.2
05C6:  BSF    03.5
05C7:  BCF    08.2
05C8:  BCF    03.5
05C9:  CLRF   2B
05CA:  BTFSC  0B.7
05CB:  BSF    2B.7
05CC:  BCF    0B.7
.................... 
.................... delay_ms(15);   // Tao thoi gian tre 15ms (Thoi gian de LCD tu reset khi moi duoc cap nguon).
05CD:  MOVLW  0F
05CE:  MOVWF  5B
05CF:  CALL   057
05D0:  BTFSC  2B.7
05D1:  BSF    0B.7
.................... 
.................... for(i=1;i<=3;i++)         // Doan lenh khoi dong C.LCD o che do 8 bit duoc thuc hien 3 lan lien tiep
05D2:  MOVLW  01
05D3:  MOVWF  42
05D4:  MOVF   42,W
05D5:  SUBLW  03
05D6:  BTFSS  03.0
05D7:  GOTO   60F
....................    {                  // tai thoi diem ban dau (de dam bao cho C.LCD hoat dong on dinh trong 
....................    lcd_send_nibble(0x03);    // truong hop khi cung cap nguon cho C.LCD ma dien ap nguon tang len cham).
05D8:  MOVLW  03
05D9:  MOVWF  62
....................    delay_ms(5);         // RS = 0, RW = 0, D7 - D4 = 0011 (0x03) -> DL = 1 (8 bit).
*
0608:  MOVLW  05
0609:  MOVWF  5B
060A:  CALL   057
060B:  BTFSC  2B.7
060C:  BSF    0B.7
060D:  INCF   42,F
060E:  GOTO   5D4
....................    }                  // Do co BF (Busy Flag) chua kiem tra duoc trong thoi diem nay, nen phai 
....................                      // thuc hien 3 lan (xem luu do khoi dong C.LCD cua nha san xuat).
.................... 
.................... lcd_send_nibble(0x02);      // Doan lenh khoi dong C.LCD o che do 4 bit. Tu luc nay thi 4 bit cao duoc ghi
060F:  MOVLW  02
0610:  MOVWF  62
....................                      // ra truoc tien, sau do la 4 bit thap.
....................                      // RS = 0, RW = 0, D7 - D4 = 0010 (0x02) -> DL = 0 (4 bit).
....................                      // Co BF (Busy Flag) co the bat dau kiem tra duoc tu luc nay.
.................... 
.................... for(i=0;i<=3;i++)
*
063A:  BCF    03.5
063B:  CLRF   42
063C:  MOVF   42,W
063D:  SUBLW  03
063E:  BTFSS  03.0
063F:  GOTO   74F
....................    lcd_send_byte(0,LCD_INIT_STRING[i]);   // Goi ham truyen thong tin (lenh) sang C.LCD.
0640:  MOVF   42,W
0641:  CALL   04F
0642:  MOVWF  43
0643:  CLRF   5F
0644:  MOVF   43,W
0645:  MOVWF  60
*
074C:  BCF    03.5
074D:  INCF   42,F
074E:  GOTO   63C
074F:  RETURN
.................... }                                 // Lenh: Thiet lap cau hinh hoat dong cho C.LCD.
.................... 
.................... // ***************************************************
.................... byte lcd_read_byte(void)   // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD.
.................... {
.................... // Khai bao bien.
.................... byte low,high;
.................... // Dinh nghia ham.
.................... output_float(LCD_DATA4);   // Thiet lap chan port o che do ngo vao.
*
0090:  BSF    08.3
*
01A6:  BSF    08.3
*
02BA:  BSF    08.3
*
03C6:  BSF    08.3
*
0649:  BSF    08.3
.................... output_float(LCD_DATA5);
*
0091:  BSF    08.4
*
01A7:  BSF    08.4
*
02BB:  BSF    08.4
*
03C7:  BSF    08.4
*
064A:  BSF    08.4
.................... output_float(LCD_DATA6);
*
0092:  BSF    08.5
*
01A8:  BSF    08.5
*
02BC:  BSF    08.5
*
03C8:  BSF    08.5
*
064B:  BSF    08.5
.................... output_float(LCD_DATA7);
*
0093:  BSF    08.6
*
01A9:  BSF    08.6
*
02BD:  BSF    08.6
*
03C9:  BSF    08.6
*
064C:  BSF    08.6
.................... 
.................... lcd_output_rw(1);         // RW = 1 - Doc thong tin tu C.LCD.
*
0094:  BCF    03.5
0095:  BSF    08.1
0096:  BSF    03.5
0097:  BCF    08.1
*
01AA:  BCF    03.5
01AB:  BSF    08.1
01AC:  BSF    03.5
01AD:  BCF    08.1
*
02BE:  BCF    03.5
02BF:  BSF    08.1
02C0:  BSF    03.5
02C1:  BCF    08.1
*
03CA:  BCF    03.5
03CB:  BSF    08.1
03CC:  BSF    03.5
03CD:  BCF    08.1
*
064D:  BCF    03.5
064E:  BSF    08.1
064F:  BSF    03.5
0650:  BCF    08.1
....................                   // Tien hanh doc 4 bit cao cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
0098:  NOP
*
01AE:  NOP
*
02C2:  NOP
*
03CE:  NOP
*
0651:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
*
0099:  BCF    03.5
009A:  BSF    08.2
009B:  BSF    03.5
009C:  BCF    08.2
*
01AF:  BCF    03.5
01B0:  BSF    08.2
01B1:  BSF    03.5
01B2:  BCF    08.2
*
02C3:  BCF    03.5
02C4:  BSF    08.2
02C5:  BSF    03.5
02C6:  BCF    08.2
*
03CF:  BCF    03.5
03D0:  BSF    08.2
03D1:  BSF    03.5
03D2:  BCF    08.2
*
0652:  BCF    03.5
0653:  BSF    08.2
0654:  BSF    03.5
0655:  BCF    08.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
009D:  NOP
*
01B3:  NOP
*
02C7:  NOP
*
03D3:  NOP
*
0656:  NOP
.................... high = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit cao).
*
00CF:  MOVF   78,W
00D0:  MOVWF  62
*
01E5:  MOVF   78,W
01E6:  MOVWF  62
*
02F9:  MOVF   78,W
02FA:  MOVWF  62
*
0405:  MOVF   78,W
0406:  MOVWF  62
*
0688:  MOVF   78,W
0689:  MOVWF  62
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
*
00D1:  BCF    08.2
00D2:  BSF    03.5
00D3:  BCF    08.2
*
01E7:  BCF    08.2
01E8:  BSF    03.5
01E9:  BCF    08.2
*
02FB:  BCF    08.2
02FC:  BSF    03.5
02FD:  BCF    08.2
*
0407:  BCF    08.2
0408:  BSF    03.5
0409:  BCF    08.2
*
068A:  BCF    08.2
068B:  BSF    03.5
068C:  BCF    08.2
....................                   // Tien hanh doc 4 bit thap cua thong tin tu C.LCD.
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
00D4:  NOP
*
01EA:  NOP
*
02FE:  NOP
*
040A:  NOP
*
068D:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD.
*
00D5:  BCF    03.5
00D6:  BSF    08.2
00D7:  BSF    03.5
00D8:  BCF    08.2
*
01EB:  BCF    03.5
01EC:  BSF    08.2
01ED:  BSF    03.5
01EE:  BCF    08.2
*
02FF:  BCF    03.5
0300:  BSF    08.2
0301:  BSF    03.5
0302:  BCF    08.2
*
040B:  BCF    03.5
040C:  BSF    08.2
040D:  BSF    03.5
040E:  BCF    08.2
*
068E:  BCF    03.5
068F:  BSF    08.2
0690:  BSF    03.5
0691:  BCF    08.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
00D9:  NOP
*
01EF:  NOP
*
0303:  NOP
*
040F:  NOP
*
0692:  NOP
.................... low = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit thap).
*
010B:  MOVF   78,W
010C:  MOVWF  61
*
0221:  MOVF   78,W
0222:  MOVWF  61
*
0335:  MOVF   78,W
0336:  MOVWF  61
*
0441:  MOVF   78,W
0442:  MOVWF  61
*
06C4:  MOVF   78,W
06C5:  MOVWF  61
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD.
*
010D:  BCF    08.2
010E:  BSF    03.5
010F:  BCF    08.2
*
0223:  BCF    08.2
0224:  BSF    03.5
0225:  BCF    08.2
*
0337:  BCF    08.2
0338:  BSF    03.5
0339:  BCF    08.2
*
0443:  BCF    08.2
0444:  BSF    03.5
0445:  BCF    08.2
*
06C6:  BCF    08.2
06C7:  BSF    03.5
06C8:  BCF    08.2
.................... 
.................... output_drive(LCD_DATA4);   // Thiet lap chan port o che do ngo ra.
*
0110:  BCF    08.3
*
0226:  BCF    08.3
*
033A:  BCF    08.3
*
0446:  BCF    08.3
*
06C9:  BCF    08.3
.................... output_drive(LCD_DATA5);
*
0111:  BCF    08.4
*
0227:  BCF    08.4
*
033B:  BCF    08.4
*
0447:  BCF    08.4
*
06CA:  BCF    08.4
.................... output_drive(LCD_DATA6);
*
0112:  BCF    08.5
*
0228:  BCF    08.5
*
033C:  BCF    08.5
*
0448:  BCF    08.5
*
06CB:  BCF    08.5
.................... output_drive(LCD_DATA7);
*
0113:  BCF    08.6
*
0229:  BCF    08.6
*
033D:  BCF    08.6
*
0449:  BCF    08.6
*
06CC:  BCF    08.6
.................... 
.................... return((high<<4) | low);   // Tra ve ket qua du lieu (dang 8 bit).
*
0114:  BCF    03.5
0115:  SWAPF  62,W
0116:  MOVWF  77
0117:  MOVLW  F0
0118:  ANDWF  77,F
0119:  MOVF   77,W
011A:  IORWF  61,W
011B:  MOVWF  78
*
022A:  BCF    03.5
022B:  SWAPF  62,W
022C:  MOVWF  77
022D:  MOVLW  F0
022E:  ANDWF  77,F
022F:  MOVF   77,W
0230:  IORWF  61,W
0231:  MOVWF  78
*
033E:  BCF    03.5
033F:  SWAPF  62,W
0340:  MOVWF  77
0341:  MOVLW  F0
0342:  ANDWF  77,F
0343:  MOVF   77,W
0344:  IORWF  61,W
0345:  MOVWF  78
*
044A:  BCF    03.5
044B:  SWAPF  62,W
044C:  MOVWF  77
044D:  MOVLW  F0
044E:  ANDWF  77,F
044F:  MOVF   77,W
0450:  IORWF  61,W
0451:  MOVWF  78
*
06CD:  BCF    03.5
06CE:  SWAPF  62,W
06CF:  MOVWF  77
06D0:  MOVLW  F0
06D1:  ANDWF  77,F
06D2:  MOVF   77,W
06D3:  IORWF  61,W
06D4:  MOVWF  78
.................... }
.................... 
.................... // ***************************************************
.................... byte lcd_read_nibble(void)   // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD.
*
009E:  BCF    03.5
009F:  CLRF   63
*
00DA:  BCF    03.5
00DB:  CLRF   63
*
01B4:  BCF    03.5
01B5:  CLRF   63
*
01F0:  BCF    03.5
01F1:  CLRF   63
*
02C8:  BCF    03.5
02C9:  CLRF   63
*
0304:  BCF    03.5
0305:  CLRF   63
*
03D4:  BCF    03.5
03D5:  CLRF   63
*
0410:  BCF    03.5
0411:  CLRF   63
*
0657:  BCF    03.5
0658:  CLRF   63
*
0693:  BCF    03.5
0694:  CLRF   63
.................... {
.................... // Khai bao bien.
.................... byte n = 0x00;   // Mac dinh gia tri ban dau cho noi chua se thong tin.
.................... // Dinh nghia ham.
.................... n |= input(LCD_DATA4);         // Doc lan luot cac bit tu bus du lieu.
*
00A0:  BSF    03.5
00A1:  BSF    08.3
00A2:  MOVLW  00
00A3:  BCF    03.5
00A4:  BTFSC  08.3
00A5:  MOVLW  01
00A6:  IORWF  63,F
*
00DC:  BSF    03.5
00DD:  BSF    08.3
00DE:  MOVLW  00
00DF:  BCF    03.5
00E0:  BTFSC  08.3
00E1:  MOVLW  01
00E2:  IORWF  63,F
*
01B6:  BSF    03.5
01B7:  BSF    08.3
01B8:  MOVLW  00
01B9:  BCF    03.5
01BA:  BTFSC  08.3
01BB:  MOVLW  01
01BC:  IORWF  63,F
*
01F2:  BSF    03.5
01F3:  BSF    08.3
01F4:  MOVLW  00
01F5:  BCF    03.5
01F6:  BTFSC  08.3
01F7:  MOVLW  01
01F8:  IORWF  63,F
*
02CA:  BSF    03.5
02CB:  BSF    08.3
02CC:  MOVLW  00
02CD:  BCF    03.5
02CE:  BTFSC  08.3
02CF:  MOVLW  01
02D0:  IORWF  63,F
*
0306:  BSF    03.5
0307:  BSF    08.3
0308:  MOVLW  00
0309:  BCF    03.5
030A:  BTFSC  08.3
030B:  MOVLW  01
030C:  IORWF  63,F
*
03D6:  BSF    03.5
03D7:  BSF    08.3
03D8:  MOVLW  00
03D9:  BCF    03.5
03DA:  BTFSC  08.3
03DB:  MOVLW  01
03DC:  IORWF  63,F
*
0412:  BSF    03.5
0413:  BSF    08.3
0414:  MOVLW  00
0415:  BCF    03.5
0416:  BTFSC  08.3
0417:  MOVLW  01
0418:  IORWF  63,F
*
0659:  BSF    03.5
065A:  BSF    08.3
065B:  MOVLW  00
065C:  BCF    03.5
065D:  BTFSC  08.3
065E:  MOVLW  01
065F:  IORWF  63,F
*
0695:  BSF    03.5
0696:  BSF    08.3
0697:  MOVLW  00
0698:  BCF    03.5
0699:  BTFSC  08.3
069A:  MOVLW  01
069B:  IORWF  63,F
.................... n |= input(LCD_DATA5) << 1;
*
00A7:  BSF    03.5
00A8:  BSF    08.4
00A9:  MOVLW  00
00AA:  BCF    03.5
00AB:  BTFSC  08.4
00AC:  MOVLW  01
00AD:  MOVWF  77
00AE:  BCF    03.0
00AF:  RLF    77,F
00B0:  MOVF   77,W
00B1:  IORWF  63,F
*
00E3:  BSF    03.5
00E4:  BSF    08.4
00E5:  MOVLW  00
00E6:  BCF    03.5
00E7:  BTFSC  08.4
00E8:  MOVLW  01
00E9:  MOVWF  77
00EA:  BCF    03.0
00EB:  RLF    77,F
00EC:  MOVF   77,W
00ED:  IORWF  63,F
*
01BD:  BSF    03.5
01BE:  BSF    08.4
01BF:  MOVLW  00
01C0:  BCF    03.5
01C1:  BTFSC  08.4
01C2:  MOVLW  01
01C3:  MOVWF  77
01C4:  BCF    03.0
01C5:  RLF    77,F
01C6:  MOVF   77,W
01C7:  IORWF  63,F
*
01F9:  BSF    03.5
01FA:  BSF    08.4
01FB:  MOVLW  00
01FC:  BCF    03.5
01FD:  BTFSC  08.4
01FE:  MOVLW  01
01FF:  MOVWF  77
0200:  BCF    03.0
0201:  RLF    77,F
0202:  MOVF   77,W
0203:  IORWF  63,F
*
02D1:  BSF    03.5
02D2:  BSF    08.4
02D3:  MOVLW  00
02D4:  BCF    03.5
02D5:  BTFSC  08.4
02D6:  MOVLW  01
02D7:  MOVWF  77
02D8:  BCF    03.0
02D9:  RLF    77,F
02DA:  MOVF   77,W
02DB:  IORWF  63,F
*
030D:  BSF    03.5
030E:  BSF    08.4
030F:  MOVLW  00
0310:  BCF    03.5
0311:  BTFSC  08.4
0312:  MOVLW  01
0313:  MOVWF  77
0314:  BCF    03.0
0315:  RLF    77,F
0316:  MOVF   77,W
0317:  IORWF  63,F
*
03DD:  BSF    03.5
03DE:  BSF    08.4
03DF:  MOVLW  00
03E0:  BCF    03.5
03E1:  BTFSC  08.4
03E2:  MOVLW  01
03E3:  MOVWF  77
03E4:  BCF    03.0
03E5:  RLF    77,F
03E6:  MOVF   77,W
03E7:  IORWF  63,F
*
0419:  BSF    03.5
041A:  BSF    08.4
041B:  MOVLW  00
041C:  BCF    03.5
041D:  BTFSC  08.4
041E:  MOVLW  01
041F:  MOVWF  77
0420:  BCF    03.0
0421:  RLF    77,F
0422:  MOVF   77,W
0423:  IORWF  63,F
*
0660:  BSF    03.5
0661:  BSF    08.4
0662:  MOVLW  00
0663:  BCF    03.5
0664:  BTFSC  08.4
0665:  MOVLW  01
0666:  MOVWF  77
0667:  BCF    03.0
0668:  RLF    77,F
0669:  MOVF   77,W
066A:  IORWF  63,F
*
069C:  BSF    03.5
069D:  BSF    08.4
069E:  MOVLW  00
069F:  BCF    03.5
06A0:  BTFSC  08.4
06A1:  MOVLW  01
06A2:  MOVWF  77
06A3:  BCF    03.0
06A4:  RLF    77,F
06A5:  MOVF   77,W
06A6:  IORWF  63,F
.................... n |= input(LCD_DATA6) << 2;
*
00B2:  BSF    03.5
00B3:  BSF    08.5
00B4:  MOVLW  00
00B5:  BCF    03.5
00B6:  BTFSC  08.5
00B7:  MOVLW  01
00B8:  MOVWF  77
00B9:  RLF    77,F
00BA:  RLF    77,F
00BB:  MOVLW  FC
00BC:  ANDWF  77,F
00BD:  MOVF   77,W
00BE:  IORWF  63,F
*
00EE:  BSF    03.5
00EF:  BSF    08.5
00F0:  MOVLW  00
00F1:  BCF    03.5
00F2:  BTFSC  08.5
00F3:  MOVLW  01
00F4:  MOVWF  77
00F5:  RLF    77,F
00F6:  RLF    77,F
00F7:  MOVLW  FC
00F8:  ANDWF  77,F
00F9:  MOVF   77,W
00FA:  IORWF  63,F
*
01C8:  BSF    03.5
01C9:  BSF    08.5
01CA:  MOVLW  00
01CB:  BCF    03.5
01CC:  BTFSC  08.5
01CD:  MOVLW  01
01CE:  MOVWF  77
01CF:  RLF    77,F
01D0:  RLF    77,F
01D1:  MOVLW  FC
01D2:  ANDWF  77,F
01D3:  MOVF   77,W
01D4:  IORWF  63,F
*
0204:  BSF    03.5
0205:  BSF    08.5
0206:  MOVLW  00
0207:  BCF    03.5
0208:  BTFSC  08.5
0209:  MOVLW  01
020A:  MOVWF  77
020B:  RLF    77,F
020C:  RLF    77,F
020D:  MOVLW  FC
020E:  ANDWF  77,F
020F:  MOVF   77,W
0210:  IORWF  63,F
*
02DC:  BSF    03.5
02DD:  BSF    08.5
02DE:  MOVLW  00
02DF:  BCF    03.5
02E0:  BTFSC  08.5
02E1:  MOVLW  01
02E2:  MOVWF  77
02E3:  RLF    77,F
02E4:  RLF    77,F
02E5:  MOVLW  FC
02E6:  ANDWF  77,F
02E7:  MOVF   77,W
02E8:  IORWF  63,F
*
0318:  BSF    03.5
0319:  BSF    08.5
031A:  MOVLW  00
031B:  BCF    03.5
031C:  BTFSC  08.5
031D:  MOVLW  01
031E:  MOVWF  77
031F:  RLF    77,F
0320:  RLF    77,F
0321:  MOVLW  FC
0322:  ANDWF  77,F
0323:  MOVF   77,W
0324:  IORWF  63,F
*
03E8:  BSF    03.5
03E9:  BSF    08.5
03EA:  MOVLW  00
03EB:  BCF    03.5
03EC:  BTFSC  08.5
03ED:  MOVLW  01
03EE:  MOVWF  77
03EF:  RLF    77,F
03F0:  RLF    77,F
03F1:  MOVLW  FC
03F2:  ANDWF  77,F
03F3:  MOVF   77,W
03F4:  IORWF  63,F
*
0424:  BSF    03.5
0425:  BSF    08.5
0426:  MOVLW  00
0427:  BCF    03.5
0428:  BTFSC  08.5
0429:  MOVLW  01
042A:  MOVWF  77
042B:  RLF    77,F
042C:  RLF    77,F
042D:  MOVLW  FC
042E:  ANDWF  77,F
042F:  MOVF   77,W
0430:  IORWF  63,F
*
066B:  BSF    03.5
066C:  BSF    08.5
066D:  MOVLW  00
066E:  BCF    03.5
066F:  BTFSC  08.5
0670:  MOVLW  01
0671:  MOVWF  77
0672:  RLF    77,F
0673:  RLF    77,F
0674:  MOVLW  FC
0675:  ANDWF  77,F
0676:  MOVF   77,W
0677:  IORWF  63,F
*
06A7:  BSF    03.5
06A8:  BSF    08.5
06A9:  MOVLW  00
06AA:  BCF    03.5
06AB:  BTFSC  08.5
06AC:  MOVLW  01
06AD:  MOVWF  77
06AE:  RLF    77,F
06AF:  RLF    77,F
06B0:  MOVLW  FC
06B1:  ANDWF  77,F
06B2:  MOVF   77,W
06B3:  IORWF  63,F
.................... n |= input(LCD_DATA7) << 3;
*
00BF:  BSF    03.5
00C0:  BSF    08.6
00C1:  MOVLW  00
00C2:  BCF    03.5
00C3:  BTFSC  08.6
00C4:  MOVLW  01
00C5:  MOVWF  77
00C6:  RLF    77,F
00C7:  RLF    77,F
00C8:  RLF    77,F
00C9:  MOVLW  F8
00CA:  ANDWF  77,F
00CB:  MOVF   77,W
00CC:  IORWF  63,F
*
00FB:  BSF    03.5
00FC:  BSF    08.6
00FD:  MOVLW  00
00FE:  BCF    03.5
00FF:  BTFSC  08.6
0100:  MOVLW  01
0101:  MOVWF  77
0102:  RLF    77,F
0103:  RLF    77,F
0104:  RLF    77,F
0105:  MOVLW  F8
0106:  ANDWF  77,F
0107:  MOVF   77,W
0108:  IORWF  63,F
*
01D5:  BSF    03.5
01D6:  BSF    08.6
01D7:  MOVLW  00
01D8:  BCF    03.5
01D9:  BTFSC  08.6
01DA:  MOVLW  01
01DB:  MOVWF  77
01DC:  RLF    77,F
01DD:  RLF    77,F
01DE:  RLF    77,F
01DF:  MOVLW  F8
01E0:  ANDWF  77,F
01E1:  MOVF   77,W
01E2:  IORWF  63,F
*
0211:  BSF    03.5
0212:  BSF    08.6
0213:  MOVLW  00
0214:  BCF    03.5
0215:  BTFSC  08.6
0216:  MOVLW  01
0217:  MOVWF  77
0218:  RLF    77,F
0219:  RLF    77,F
021A:  RLF    77,F
021B:  MOVLW  F8
021C:  ANDWF  77,F
021D:  MOVF   77,W
021E:  IORWF  63,F
*
02E9:  BSF    03.5
02EA:  BSF    08.6
02EB:  MOVLW  00
02EC:  BCF    03.5
02ED:  BTFSC  08.6
02EE:  MOVLW  01
02EF:  MOVWF  77
02F0:  RLF    77,F
02F1:  RLF    77,F
02F2:  RLF    77,F
02F3:  MOVLW  F8
02F4:  ANDWF  77,F
02F5:  MOVF   77,W
02F6:  IORWF  63,F
*
0325:  BSF    03.5
0326:  BSF    08.6
0327:  MOVLW  00
0328:  BCF    03.5
0329:  BTFSC  08.6
032A:  MOVLW  01
032B:  MOVWF  77
032C:  RLF    77,F
032D:  RLF    77,F
032E:  RLF    77,F
032F:  MOVLW  F8
0330:  ANDWF  77,F
0331:  MOVF   77,W
0332:  IORWF  63,F
*
03F5:  BSF    03.5
03F6:  BSF    08.6
03F7:  MOVLW  00
03F8:  BCF    03.5
03F9:  BTFSC  08.6
03FA:  MOVLW  01
03FB:  MOVWF  77
03FC:  RLF    77,F
03FD:  RLF    77,F
03FE:  RLF    77,F
03FF:  MOVLW  F8
0400:  ANDWF  77,F
0401:  MOVF   77,W
0402:  IORWF  63,F
*
0431:  BSF    03.5
0432:  BSF    08.6
0433:  MOVLW  00
0434:  BCF    03.5
0435:  BTFSC  08.6
0436:  MOVLW  01
0437:  MOVWF  77
0438:  RLF    77,F
0439:  RLF    77,F
043A:  RLF    77,F
043B:  MOVLW  F8
043C:  ANDWF  77,F
043D:  MOVF   77,W
043E:  IORWF  63,F
*
0678:  BSF    03.5
0679:  BSF    08.6
067A:  MOVLW  00
067B:  BCF    03.5
067C:  BTFSC  08.6
067D:  MOVLW  01
067E:  MOVWF  77
067F:  RLF    77,F
0680:  RLF    77,F
0681:  RLF    77,F
0682:  MOVLW  F8
0683:  ANDWF  77,F
0684:  MOVF   77,W
0685:  IORWF  63,F
*
06B4:  BSF    03.5
06B5:  BSF    08.6
06B6:  MOVLW  00
06B7:  BCF    03.5
06B8:  BTFSC  08.6
06B9:  MOVLW  01
06BA:  MOVWF  77
06BB:  RLF    77,F
06BC:  RLF    77,F
06BD:  RLF    77,F
06BE:  MOVLW  F8
06BF:  ANDWF  77,F
06C0:  MOVF   77,W
06C1:  IORWF  63,F
.................... 
.................... return(n);   // Tra ve ket qua doc duoc (data = 0000 xxxx).
*
00CD:  MOVF   63,W
00CE:  MOVWF  78
*
0109:  MOVF   63,W
010A:  MOVWF  78
*
01E3:  MOVF   63,W
01E4:  MOVWF  78
*
021F:  MOVF   63,W
0220:  MOVWF  78
*
02F7:  MOVF   63,W
02F8:  MOVWF  78
*
0333:  MOVF   63,W
0334:  MOVWF  78
*
0403:  MOVF   63,W
0404:  MOVWF  78
*
043F:  MOVF   63,W
0440:  MOVWF  78
*
0686:  MOVF   63,W
0687:  MOVWF  78
*
06C2:  MOVF   63,W
06C3:  MOVWF  78
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_byte(byte address, byte n)   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address).
.................... {                                 // address = 0: Lenh / 1: Du lieu.
....................                                  // byte = Thong tin can gui (8 bit).
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham.  
.................... lcd_output_rs(0);      // RS = 0 - Databus = Bus lenh.
*
008D:  BCF    08.0
008E:  BSF    03.5
008F:  BCF    08.0
*
01A3:  BCF    08.0
01A4:  BSF    03.5
01A5:  BCF    08.0
*
02B7:  BCF    08.0
02B8:  BSF    03.5
02B9:  BCF    08.0
*
03C3:  BCF    08.0
03C4:  BSF    03.5
03C5:  BCF    08.0
*
0646:  BCF    08.0
0647:  BSF    03.5
0648:  BCF    08.0
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
*
011C:  MOVF   78,W
011D:  MOVWF  61
011E:  BTFSS  61.7
011F:  GOTO   122
0120:  BSF    03.5
0121:  GOTO   090
*
0232:  MOVF   78,W
0233:  MOVWF  61
0234:  BTFSS  61.7
0235:  GOTO   238
0236:  BSF    03.5
0237:  GOTO   1A6
*
0346:  MOVF   78,W
0347:  MOVWF  61
0348:  BTFSS  61.7
0349:  GOTO   34C
034A:  BSF    03.5
034B:  GOTO   2BA
*
0452:  MOVF   78,W
0453:  MOVWF  61
0454:  BTFSS  61.7
0455:  GOTO   458
0456:  BSF    03.5
0457:  GOTO   3C6
*
06D5:  MOVF   78,W
06D6:  MOVWF  61
06D7:  BTFSS  61.7
06D8:  GOTO   6DB
06D9:  BSF    03.5
06DA:  GOTO   649
.................... lcd_output_rs(address);   // RS = address - Databus = Bus lenh/du lieu.
*
0122:  MOVF   5F,F
0123:  BTFSS  03.2
0124:  GOTO   127
0125:  BCF    08.0
0126:  GOTO   128
0127:  BSF    08.0
0128:  BSF    03.5
0129:  BCF    08.0
*
0238:  MOVF   5F,F
0239:  BTFSS  03.2
023A:  GOTO   23D
023B:  BCF    08.0
023C:  GOTO   23E
023D:  BSF    08.0
023E:  BSF    03.5
023F:  BCF    08.0
*
034C:  MOVF   5F,F
034D:  BTFSS  03.2
034E:  GOTO   351
034F:  BCF    08.0
0350:  GOTO   352
0351:  BSF    08.0
0352:  BSF    03.5
0353:  BCF    08.0
*
0458:  MOVF   5F,F
0459:  BTFSS  03.2
045A:  GOTO   45D
045B:  BCF    08.0
045C:  GOTO   45E
045D:  BSF    08.0
045E:  BSF    03.5
045F:  BCF    08.0
*
06DB:  MOVF   5F,F
06DC:  BTFSS  03.2
06DD:  GOTO   6E0
06DE:  BCF    08.0
06DF:  GOTO   6E1
06E0:  BSF    08.0
06E1:  BSF    03.5
06E2:  BCF    08.0
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
012A:  NOP
*
0240:  NOP
*
0354:  NOP
*
0460:  NOP
*
06E3:  NOP
.................... lcd_output_rw(0);      // RW = 0 - Ghi thong tin vao C.LCD.
*
012B:  BCF    03.5
012C:  BCF    08.1
012D:  BSF    03.5
012E:  BCF    08.1
*
0241:  BCF    03.5
0242:  BCF    08.1
0243:  BSF    03.5
0244:  BCF    08.1
*
0355:  BCF    03.5
0356:  BCF    08.1
0357:  BSF    03.5
0358:  BCF    08.1
*
0461:  BCF    03.5
0462:  BCF    08.1
0463:  BSF    03.5
0464:  BCF    08.1
*
06E4:  BCF    03.5
06E5:  BCF    08.1
06E6:  BSF    03.5
06E7:  BCF    08.1
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
012F:  NOP
*
0245:  NOP
*
0359:  NOP
*
0465:  NOP
*
06E8:  NOP
.................... lcd_output_enable(0);   // EN = 0 - Cam truy xuat C.LCD.
*
0130:  BCF    03.5
0131:  BCF    08.2
0132:  BSF    03.5
0133:  BCF    08.2
*
0246:  BCF    03.5
0247:  BCF    08.2
0248:  BSF    03.5
0249:  BCF    08.2
*
035A:  BCF    03.5
035B:  BCF    08.2
035C:  BSF    03.5
035D:  BCF    08.2
*
0466:  BCF    03.5
0467:  BCF    08.2
0468:  BSF    03.5
0469:  BCF    08.2
*
06E9:  BCF    03.5
06EA:  BCF    08.2
06EB:  BSF    03.5
06EC:  BCF    08.2
.................... lcd_send_nibble(n >> 4);   // Goi ham truyen 4 bit cao sang C.LCD.
*
0134:  BCF    03.5
0135:  SWAPF  60,W
0136:  MOVWF  61
0137:  MOVLW  0F
0138:  ANDWF  61,F
0139:  MOVF   61,W
013A:  MOVWF  62
*
024A:  BCF    03.5
024B:  SWAPF  60,W
024C:  MOVWF  61
024D:  MOVLW  0F
024E:  ANDWF  61,F
024F:  MOVF   61,W
0250:  MOVWF  62
*
035E:  BCF    03.5
035F:  SWAPF  60,W
0360:  MOVWF  61
0361:  MOVLW  0F
0362:  ANDWF  61,F
0363:  MOVF   61,W
0364:  MOVWF  62
*
046A:  BCF    03.5
046B:  SWAPF  60,W
046C:  MOVWF  61
046D:  MOVLW  0F
046E:  ANDWF  61,F
046F:  MOVF   61,W
0470:  MOVWF  62
*
06ED:  BCF    03.5
06EE:  SWAPF  60,W
06EF:  MOVWF  61
06F0:  MOVLW  0F
06F1:  ANDWF  61,F
06F2:  MOVF   61,W
06F3:  MOVWF  62
.................... lcd_send_nibble(n & 0x0F);   // Goi ham truyen 4 bit thap sang C.LCD.
*
0164:  BCF    03.5
0165:  MOVF   60,W
0166:  ANDLW  0F
0167:  MOVWF  61
0168:  MOVF   61,W
0169:  MOVWF  62
*
027A:  BCF    03.5
027B:  MOVF   60,W
027C:  ANDLW  0F
027D:  MOVWF  61
027E:  MOVF   61,W
027F:  MOVWF  62
*
038E:  BCF    03.5
038F:  MOVF   60,W
0390:  ANDLW  0F
0391:  MOVWF  61
0392:  MOVF   61,W
0393:  MOVWF  62
*
049A:  BCF    03.5
049B:  MOVF   60,W
049C:  ANDLW  0F
049D:  MOVWF  61
049E:  MOVF   61,W
049F:  MOVWF  62
*
071D:  BCF    03.5
071E:  MOVF   60,W
071F:  ANDLW  0F
0720:  MOVWF  61
0721:  MOVF   61,W
0722:  MOVWF  62
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_send_nibble(byte n)   // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD.
.................... {                        // n = Thong tin can gui. 4 bit can gui phai nam vi tri 4 bit thap.
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... output_bit(LCD_DATA4, bit_test(n, 0));   // Xuat lan luot cac bit len bus du lieu.
*
013B:  BTFSC  62.0
013C:  GOTO   13F
013D:  BCF    08.3
013E:  GOTO   140
013F:  BSF    08.3
0140:  BSF    03.5
0141:  BCF    08.3
*
016A:  BTFSC  62.0
016B:  GOTO   16E
016C:  BCF    08.3
016D:  GOTO   16F
016E:  BSF    08.3
016F:  BSF    03.5
0170:  BCF    08.3
*
0251:  BTFSC  62.0
0252:  GOTO   255
0253:  BCF    08.3
0254:  GOTO   256
0255:  BSF    08.3
0256:  BSF    03.5
0257:  BCF    08.3
*
0280:  BTFSC  62.0
0281:  GOTO   284
0282:  BCF    08.3
0283:  GOTO   285
0284:  BSF    08.3
0285:  BSF    03.5
0286:  BCF    08.3
*
0365:  BTFSC  62.0
0366:  GOTO   369
0367:  BCF    08.3
0368:  GOTO   36A
0369:  BSF    08.3
036A:  BSF    03.5
036B:  BCF    08.3
*
0394:  BTFSC  62.0
0395:  GOTO   398
0396:  BCF    08.3
0397:  GOTO   399
0398:  BSF    08.3
0399:  BSF    03.5
039A:  BCF    08.3
*
0471:  BTFSC  62.0
0472:  GOTO   475
0473:  BCF    08.3
0474:  GOTO   476
0475:  BSF    08.3
0476:  BSF    03.5
0477:  BCF    08.3
*
04A0:  BTFSC  62.0
04A1:  GOTO   4A4
04A2:  BCF    08.3
04A3:  GOTO   4A5
04A4:  BSF    08.3
04A5:  BSF    03.5
04A6:  BCF    08.3
*
05DA:  BTFSC  62.0
05DB:  GOTO   5DE
05DC:  BCF    08.3
05DD:  GOTO   5DF
05DE:  BSF    08.3
05DF:  BSF    03.5
05E0:  BCF    08.3
*
0611:  BTFSC  62.0
0612:  GOTO   615
0613:  BCF    08.3
0614:  GOTO   616
0615:  BSF    08.3
0616:  BSF    03.5
0617:  BCF    08.3
*
06F4:  BTFSC  62.0
06F5:  GOTO   6F8
06F6:  BCF    08.3
06F7:  GOTO   6F9
06F8:  BSF    08.3
06F9:  BSF    03.5
06FA:  BCF    08.3
*
0723:  BTFSC  62.0
0724:  GOTO   727
0725:  BCF    08.3
0726:  GOTO   728
0727:  BSF    08.3
0728:  BSF    03.5
0729:  BCF    08.3
.................... output_bit(LCD_DATA5, bit_test(n, 1));
*
0142:  BCF    03.5
0143:  BTFSC  62.1
0144:  GOTO   147
0145:  BCF    08.4
0146:  GOTO   148
0147:  BSF    08.4
0148:  BSF    03.5
0149:  BCF    08.4
*
0171:  BCF    03.5
0172:  BTFSC  62.1
0173:  GOTO   176
0174:  BCF    08.4
0175:  GOTO   177
0176:  BSF    08.4
0177:  BSF    03.5
0178:  BCF    08.4
*
0258:  BCF    03.5
0259:  BTFSC  62.1
025A:  GOTO   25D
025B:  BCF    08.4
025C:  GOTO   25E
025D:  BSF    08.4
025E:  BSF    03.5
025F:  BCF    08.4
*
0287:  BCF    03.5
0288:  BTFSC  62.1
0289:  GOTO   28C
028A:  BCF    08.4
028B:  GOTO   28D
028C:  BSF    08.4
028D:  BSF    03.5
028E:  BCF    08.4
*
036C:  BCF    03.5
036D:  BTFSC  62.1
036E:  GOTO   371
036F:  BCF    08.4
0370:  GOTO   372
0371:  BSF    08.4
0372:  BSF    03.5
0373:  BCF    08.4
*
039B:  BCF    03.5
039C:  BTFSC  62.1
039D:  GOTO   3A0
039E:  BCF    08.4
039F:  GOTO   3A1
03A0:  BSF    08.4
03A1:  BSF    03.5
03A2:  BCF    08.4
*
0478:  BCF    03.5
0479:  BTFSC  62.1
047A:  GOTO   47D
047B:  BCF    08.4
047C:  GOTO   47E
047D:  BSF    08.4
047E:  BSF    03.5
047F:  BCF    08.4
*
04A7:  BCF    03.5
04A8:  BTFSC  62.1
04A9:  GOTO   4AC
04AA:  BCF    08.4
04AB:  GOTO   4AD
04AC:  BSF    08.4
04AD:  BSF    03.5
04AE:  BCF    08.4
*
05E1:  BCF    03.5
05E2:  BTFSC  62.1
05E3:  GOTO   5E6
05E4:  BCF    08.4
05E5:  GOTO   5E7
05E6:  BSF    08.4
05E7:  BSF    03.5
05E8:  BCF    08.4
*
0618:  BCF    03.5
0619:  BTFSC  62.1
061A:  GOTO   61D
061B:  BCF    08.4
061C:  GOTO   61E
061D:  BSF    08.4
061E:  BSF    03.5
061F:  BCF    08.4
*
06FB:  BCF    03.5
06FC:  BTFSC  62.1
06FD:  GOTO   700
06FE:  BCF    08.4
06FF:  GOTO   701
0700:  BSF    08.4
0701:  BSF    03.5
0702:  BCF    08.4
*
072A:  BCF    03.5
072B:  BTFSC  62.1
072C:  GOTO   72F
072D:  BCF    08.4
072E:  GOTO   730
072F:  BSF    08.4
0730:  BSF    03.5
0731:  BCF    08.4
.................... output_bit(LCD_DATA6, bit_test(n, 2));
*
014A:  BCF    03.5
014B:  BTFSC  62.2
014C:  GOTO   14F
014D:  BCF    08.5
014E:  GOTO   150
014F:  BSF    08.5
0150:  BSF    03.5
0151:  BCF    08.5
*
0179:  BCF    03.5
017A:  BTFSC  62.2
017B:  GOTO   17E
017C:  BCF    08.5
017D:  GOTO   17F
017E:  BSF    08.5
017F:  BSF    03.5
0180:  BCF    08.5
*
0260:  BCF    03.5
0261:  BTFSC  62.2
0262:  GOTO   265
0263:  BCF    08.5
0264:  GOTO   266
0265:  BSF    08.5
0266:  BSF    03.5
0267:  BCF    08.5
*
028F:  BCF    03.5
0290:  BTFSC  62.2
0291:  GOTO   294
0292:  BCF    08.5
0293:  GOTO   295
0294:  BSF    08.5
0295:  BSF    03.5
0296:  BCF    08.5
*
0374:  BCF    03.5
0375:  BTFSC  62.2
0376:  GOTO   379
0377:  BCF    08.5
0378:  GOTO   37A
0379:  BSF    08.5
037A:  BSF    03.5
037B:  BCF    08.5
*
03A3:  BCF    03.5
03A4:  BTFSC  62.2
03A5:  GOTO   3A8
03A6:  BCF    08.5
03A7:  GOTO   3A9
03A8:  BSF    08.5
03A9:  BSF    03.5
03AA:  BCF    08.5
*
0480:  BCF    03.5
0481:  BTFSC  62.2
0482:  GOTO   485
0483:  BCF    08.5
0484:  GOTO   486
0485:  BSF    08.5
0486:  BSF    03.5
0487:  BCF    08.5
*
04AF:  BCF    03.5
04B0:  BTFSC  62.2
04B1:  GOTO   4B4
04B2:  BCF    08.5
04B3:  GOTO   4B5
04B4:  BSF    08.5
04B5:  BSF    03.5
04B6:  BCF    08.5
*
05E9:  BCF    03.5
05EA:  BTFSC  62.2
05EB:  GOTO   5EE
05EC:  BCF    08.5
05ED:  GOTO   5EF
05EE:  BSF    08.5
05EF:  BSF    03.5
05F0:  BCF    08.5
*
0620:  BCF    03.5
0621:  BTFSC  62.2
0622:  GOTO   625
0623:  BCF    08.5
0624:  GOTO   626
0625:  BSF    08.5
0626:  BSF    03.5
0627:  BCF    08.5
*
0703:  BCF    03.5
0704:  BTFSC  62.2
0705:  GOTO   708
0706:  BCF    08.5
0707:  GOTO   709
0708:  BSF    08.5
0709:  BSF    03.5
070A:  BCF    08.5
*
0732:  BCF    03.5
0733:  BTFSC  62.2
0734:  GOTO   737
0735:  BCF    08.5
0736:  GOTO   738
0737:  BSF    08.5
0738:  BSF    03.5
0739:  BCF    08.5
.................... output_bit(LCD_DATA7, bit_test(n, 3));
*
0152:  BCF    03.5
0153:  BTFSC  62.3
0154:  GOTO   157
0155:  BCF    08.6
0156:  GOTO   158
0157:  BSF    08.6
0158:  BSF    03.5
0159:  BCF    08.6
*
0181:  BCF    03.5
0182:  BTFSC  62.3
0183:  GOTO   186
0184:  BCF    08.6
0185:  GOTO   187
0186:  BSF    08.6
0187:  BSF    03.5
0188:  BCF    08.6
*
0268:  BCF    03.5
0269:  BTFSC  62.3
026A:  GOTO   26D
026B:  BCF    08.6
026C:  GOTO   26E
026D:  BSF    08.6
026E:  BSF    03.5
026F:  BCF    08.6
*
0297:  BCF    03.5
0298:  BTFSC  62.3
0299:  GOTO   29C
029A:  BCF    08.6
029B:  GOTO   29D
029C:  BSF    08.6
029D:  BSF    03.5
029E:  BCF    08.6
*
037C:  BCF    03.5
037D:  BTFSC  62.3
037E:  GOTO   381
037F:  BCF    08.6
0380:  GOTO   382
0381:  BSF    08.6
0382:  BSF    03.5
0383:  BCF    08.6
*
03AB:  BCF    03.5
03AC:  BTFSC  62.3
03AD:  GOTO   3B0
03AE:  BCF    08.6
03AF:  GOTO   3B1
03B0:  BSF    08.6
03B1:  BSF    03.5
03B2:  BCF    08.6
*
0488:  BCF    03.5
0489:  BTFSC  62.3
048A:  GOTO   48D
048B:  BCF    08.6
048C:  GOTO   48E
048D:  BSF    08.6
048E:  BSF    03.5
048F:  BCF    08.6
*
04B7:  BCF    03.5
04B8:  BTFSC  62.3
04B9:  GOTO   4BC
04BA:  BCF    08.6
04BB:  GOTO   4BD
04BC:  BSF    08.6
04BD:  BSF    03.5
04BE:  BCF    08.6
*
05F1:  BCF    03.5
05F2:  BTFSC  62.3
05F3:  GOTO   5F6
05F4:  BCF    08.6
05F5:  GOTO   5F7
05F6:  BSF    08.6
05F7:  BSF    03.5
05F8:  BCF    08.6
*
0628:  BCF    03.5
0629:  BTFSC  62.3
062A:  GOTO   62D
062B:  BCF    08.6
062C:  GOTO   62E
062D:  BSF    08.6
062E:  BSF    03.5
062F:  BCF    08.6
*
070B:  BCF    03.5
070C:  BTFSC  62.3
070D:  GOTO   710
070E:  BCF    08.6
070F:  GOTO   711
0710:  BSF    08.6
0711:  BSF    03.5
0712:  BCF    08.6
*
073A:  BCF    03.5
073B:  BTFSC  62.3
073C:  GOTO   73F
073D:  BCF    08.6
073E:  GOTO   740
073F:  BSF    08.6
0740:  BSF    03.5
0741:  BCF    08.6
....................     
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz).
*
015A:  NOP
*
0189:  NOP
*
0270:  NOP
*
029F:  NOP
*
0384:  NOP
*
03B3:  NOP
*
0490:  NOP
*
04BF:  NOP
*
05F9:  NOP
*
0630:  NOP
*
0713:  NOP
*
0742:  NOP
.................... lcd_output_enable(1);   // Tao xung ghi thong tin vao C.LCD.
*
015B:  BCF    03.5
015C:  BSF    08.2
015D:  BSF    03.5
015E:  BCF    08.2
*
018A:  BCF    03.5
018B:  BSF    08.2
018C:  BSF    03.5
018D:  BCF    08.2
*
0271:  BCF    03.5
0272:  BSF    08.2
0273:  BSF    03.5
0274:  BCF    08.2
*
02A0:  BCF    03.5
02A1:  BSF    08.2
02A2:  BSF    03.5
02A3:  BCF    08.2
*
0385:  BCF    03.5
0386:  BSF    08.2
0387:  BSF    03.5
0388:  BCF    08.2
*
03B4:  BCF    03.5
03B5:  BSF    08.2
03B6:  BSF    03.5
03B7:  BCF    08.2
*
0491:  BCF    03.5
0492:  BSF    08.2
0493:  BSF    03.5
0494:  BCF    08.2
*
04C0:  BCF    03.5
04C1:  BSF    08.2
04C2:  BSF    03.5
04C3:  BCF    08.2
*
05FA:  BCF    03.5
05FB:  BSF    08.2
05FC:  BSF    03.5
05FD:  BCF    08.2
*
0631:  BCF    03.5
0632:  BSF    08.2
0633:  BSF    03.5
0634:  BCF    08.2
*
0714:  BCF    03.5
0715:  BSF    08.2
0716:  BSF    03.5
0717:  BCF    08.2
*
0743:  BCF    03.5
0744:  BSF    08.2
0745:  BSF    03.5
0746:  BCF    08.2
.................... delay_us(2);         // Tao tre 2 chu ky (t=2us voi fosc=4MHz).
*
015F:  GOTO   160
*
018E:  GOTO   18F
*
0275:  GOTO   276
*
02A4:  GOTO   2A5
*
0389:  GOTO   38A
*
03B8:  GOTO   3B9
*
0495:  GOTO   496
*
04C4:  GOTO   4C5
*
05FE:  GOTO   5FF
*
0635:  GOTO   636
*
0718:  GOTO   719
*
0747:  GOTO   748
.................... lcd_output_enable(0);   // Tao xung ghi thong tin vao LCD - EN = 1->0 (High to Low).
*
0160:  BCF    03.5
0161:  BCF    08.2
0162:  BSF    03.5
0163:  BCF    08.2
*
018F:  BCF    03.5
0190:  BCF    08.2
0191:  BSF    03.5
0192:  BCF    08.2
*
0276:  BCF    03.5
0277:  BCF    08.2
0278:  BSF    03.5
0279:  BCF    08.2
*
02A5:  BCF    03.5
02A6:  BCF    08.2
02A7:  BSF    03.5
02A8:  BCF    08.2
*
038A:  BCF    03.5
038B:  BCF    08.2
038C:  BSF    03.5
038D:  BCF    08.2
*
03B9:  BCF    03.5
03BA:  BCF    08.2
03BB:  BSF    03.5
03BC:  BCF    08.2
*
0496:  BCF    03.5
0497:  BCF    08.2
0498:  BSF    03.5
0499:  BCF    08.2
*
04C5:  BCF    03.5
04C6:  BCF    08.2
04C7:  BSF    03.5
04C8:  BCF    08.2
*
05FF:  BCF    03.5
0600:  BCF    08.2
0601:  BSF    03.5
0602:  BCF    08.2
0603:  BCF    03.5
0604:  CLRF   2B
0605:  BTFSC  0B.7
0606:  BSF    2B.7
0607:  BCF    0B.7
*
0636:  BCF    03.5
0637:  BCF    08.2
0638:  BSF    03.5
0639:  BCF    08.2
*
0719:  BCF    03.5
071A:  BCF    08.2
071B:  BSF    03.5
071C:  BCF    08.2
*
0748:  BCF    03.5
0749:  BCF    08.2
074A:  BSF    03.5
074B:  BCF    08.2
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_gotoxy(byte x, byte y)   // Ham thiet lap vi tri ghi tren C.LCD (Goc tren ben trai co toa do la 1,1).
.................... {
.................... // Khai bao bien.
.................... byte address;
.................... // Dinh nghia ham.  
.................... if(y==1)               // Kiem tra vi tri truy xuat thuoc hang 2.
*
006C:  DECFSZ 5C,W
006D:  GOTO   070
....................    address=lcd_line_one;      // Nap dia chi RAM cua hang 2. 
006E:  CLRF   5D
006F:  GOTO   084
.................... else if(y==2)      // Neu vi tri truy xuat thuoc hang 1.
0070:  MOVF   5C,W
0071:  SUBLW  02
0072:  BTFSS  03.2
0073:  GOTO   077
....................    address=lcd_line_two;      // Nap dia chi RAM cua hang 1.
0074:  MOVLW  40
0075:  MOVWF  5D
0076:  GOTO   084
.................... else if(y==3)
0077:  MOVF   5C,W
0078:  SUBLW  03
0079:  BTFSS  03.2
007A:  GOTO   07E
....................    address=lcd_line_three;     
007B:  MOVLW  14
007C:  MOVWF  5D
007D:  GOTO   084
.................... else if(y==4)
007E:  MOVF   5C,W
007F:  SUBLW  04
0080:  BTFSS  03.2
0081:  GOTO   084
....................    address=lcd_line_four;   
0082:  MOVLW  54
0083:  MOVWF  5D
.................... 
.................... address+=x-1;               // Ghep dia chi cot vao dia chi tong quat (address). address = address + (x-1).      
0084:  MOVLW  01
0085:  SUBWF  5B,W
0086:  ADDWF  5D,F
....................                         // Ta qui uoc: Goc tren ben trai co toa do la 1,1 -> Cot dau tien la Cot 1
....................                         // (x-1) vi C.LCD qui uoc cot dau tien co dia chi la 0.
.................... lcd_send_byte(0,0x80|address);   // Goi ham truyen thong tin (lenh) sang C.LCD.
0087:  MOVF   5D,W
0088:  IORLW  80
0089:  MOVWF  5E
008A:  CLRF   5F
008B:  MOVF   5E,W
008C:  MOVWF  60
*
0193:  BCF    03.5
0194:  RETURN
.................... }                        // Lenh: Thiet lap dia chi DDRAM cua C.LCD (addresss).   
.................... 
.................... // ***************************************************
.................... char lcd_getc(byte x, byte y)   // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... char value;
.................... // Dinh nghia ham.  
.................... lcd_gotoxy(x,y);            // Xac dinh toa do C.LCD can truy xuat.
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong).
.................... lcd_output_rs(1);         // RS = 1 - Databus = Bus du lieu.
.................... value = lcd_read_byte();   // Doc ve tu C.LCD.
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh.
.................... 
.................... return(value);      // Tra ve ma ky tu tai toa do yeu cau.
.................... }
.................... 
.................... // ***************************************************
.................... void lcd_putc(char c)   // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD.
.................... {
.................... // Khai bao bien.
.................... 
.................... // Dinh nghia ham. 
.................... switch (c)
0195:  MOVF   5A,W
0196:  XORLW  0C
0197:  BTFSC  03.2
0198:  GOTO   1A0
0199:  XORLW  06
019A:  BTFSC  03.2
019B:  GOTO   2AE
019C:  XORLW  02
019D:  BTFSC  03.2
019E:  GOTO   2B4
019F:  GOTO   3BF
....................    {
....................    case '\f':     // Chuc nang xoa hien thi.
....................       lcd_send_byte(0,0x01);   // Goi ham truyen thong tin (lenh) sang C.LCD.
01A0:  CLRF   5F
01A1:  MOVLW  01
01A2:  MOVWF  60
....................       delay_ms(2);         // Lenh: Xoa hien thi tren man hinh C.LCD (0x01).
*
02A9:  MOVLW  02
02AA:  BCF    03.5
02AB:  MOVWF  5B
02AC:  CALL   057
....................       break;
02AD:  GOTO   4CA
....................    case '\n':       // Chuc nang bat dau hang thu 2.
....................          lcd_gotoxy(1,0x02);     // Goi ham truyen thong tin (du lieu) sang C.LCD.   
02AE:  MOVLW  01
02AF:  MOVWF  5B
02B0:  MOVLW  02
02B1:  MOVWF  5C
02B2:  CALL   06C
....................       break;
02B3:  GOTO   4CA
....................     case '\b':       // Chuc nang lui ve 1 vi tri.
....................       lcd_send_byte(0,0x10);    // Goi ham truyen thong tin (lenh) sang C.LCD. 
02B4:  CLRF   5F
02B5:  MOVLW  10
02B6:  MOVWF  60
....................       break;               // Lenh: Doi con tro sang trai (0x10).
*
03BD:  BCF    03.5
03BE:  GOTO   4CA
....................    default:       // Chuc nang hien thi ky tu c tai vi tri ke tiep tren C.LCD.
....................       lcd_send_byte(1,c);     // Goi ham truyen thong tin (du lieu) sang C.LCD.
03BF:  MOVLW  01
03C0:  MOVWF  5F
03C1:  MOVF   5A,W
03C2:  MOVWF  60
....................       break;
*
04C9:  BCF    03.5
....................    }
04CA:  RETURN
.................... }      
.................... // ***************************************************   
.................... 
.................... #include <DS1307.c>  // include DS1307 driver source file
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                             DS1307.c                              ////
.................... ////                                                                   ////
.................... ////                      Driver for CCS C compiler                    ////
.................... ////                                                                   ////
.................... ////     Driver for Maxim DS1307 serial I2C real-time clock (RTC).     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                     https://simple-circuit.com/                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #if defined DS1307_I2C_NO_STREAM
....................   #define RTC_I2C_START()   i2c_start()
....................   #define RTC_I2C_STOP()    i2c_stop()
....................   #define RTC_I2C_WRITE(x)  i2c_write(x)
....................   #define RTC_I2C_READ(x)   i2c_read(x)
.................... #elif defined DS1307_I2C_STREAM
....................   #define RTC_I2C_START()   i2c_start(DS1307_I2C_STREAM)
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_I2C_STREAM)
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_I2C_STREAM, x)
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_I2C_STREAM, x)
.................... #else
....................   #define RTC_I2C_START()   i2c_start(DS1307_STREAM)
....................   #define RTC_I2C_STOP()    i2c_stop(DS1307_STREAM)
....................   #define RTC_I2C_WRITE(x)  i2c_write(DS1307_STREAM, x)
....................   #define RTC_I2C_READ(x)   i2c_read(DS1307_STREAM, x)
.................... #endif
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #define DS1307_ADDRESS      0xD0
.................... #define DS1307_REG_SECONDS  0x00
.................... #define DS1307_REG_CONTROL  0x07
.................... 
.................... enum SQWE
.................... {
....................   OUT_OFF = 0x00,
....................   OUT_ON  = 0x80,
....................   OUT_1Hz = 0x10,
....................   OUT_4096Hz  = 0x11,
....................   OUT_8192Hz  = 0x12,
....................   OUT_32768Hz = 0x13
.................... };
.................... 
.................... typedef enum
.................... {
....................   SUNDAY = 1,
....................   MONDAY,
....................   TUESDAY,
....................   WEDNESDAY,
....................   THURSDAY,
....................   FRIDAY,
....................   SATURDAY
.................... } RTC_DOW;
.................... 
.................... typedef enum
.................... {
....................   JANUARY = 1,
....................   FEBRUARY,
....................   MARCH,
....................   APRIL,
....................   MAY,
....................   JUNE,
....................   JULY,
....................   AUGUST,
....................   SEPTEMBER,
....................   OCTOBER,
....................   NOVEMBER,
....................   DECEMBER
.................... } RTC_Month;
.................... 
.................... typedef struct rtc_tm
.................... {
....................   uint8_t seconds;
....................   uint8_t minutes;
....................   uint8_t hours;
....................   RTC_DOW dow;
....................   uint8_t day;
....................   RTC_Month month;
....................   uint8_t year;
.................... } RTC_Time;
.................... 
.................... ///////////////////////// All Functions /////////////////////////
....................                                                                //
.................... uint8_t bcd_to_decimal(uint8_t number);                        //
.................... uint8_t decimal_to_bcd(uint8_t number);                        //
.................... void RTC_Set(RTC_Time *time_t);                                //
.................... RTC_Time *RTC_Get();                                           //
.................... void OSC_Enable();                                             //
.................... void OSC_Disable();                                            //
.................... uint8_t RTC_Read_Reg(uint8_t reg_address);                     //
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value);    //
.................... void SQWE_Set(SQWE pin_out);                                   //
....................                                                                //
.................... /////////////////////////////////////////////////////////////////
.................... 
.................... // converts BCD to decimal
.................... uint8_t bcd_to_decimal(uint8_t number)
.................... {
....................   return ( (number >> 4) * 10 + (number & 0x0F) );
.................... }
.................... 
.................... // converts decimal to BCD
.................... uint8_t decimal_to_bcd(uint8_t number)
.................... {
....................   return ( ((number / 10) << 4) + (number % 10) );
.................... }
.................... 
.................... // sets time and date
.................... void RTC_Set(RTC_Time *time_t)
.................... {
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS);
.................... 
....................   // convert decimal to BCD
....................   time_t->day     = decimal_to_bcd(time_t->day);
....................   time_t->month   = decimal_to_bcd(time_t->month);
....................   time_t->year    = decimal_to_bcd(time_t->year);
....................   time_t->hours   = decimal_to_bcd(time_t->hours);
....................   time_t->minutes = decimal_to_bcd(time_t->minutes);
....................   time_t->seconds = decimal_to_bcd(time_t->seconds);
....................   // end conversion
....................   
....................   // test if oscillator is disabled (CH bit = 1)
....................   if(sec_reg & 0x80)
....................     time_t->seconds |= 0x80;
.................... 
....................   // write data to the RTC chip
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS);
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS);
....................   RTC_I2C_WRITE(time_t->seconds);
....................   RTC_I2C_WRITE(time_t->minutes);
....................   RTC_I2C_WRITE(time_t->hours);
....................   RTC_I2C_WRITE(time_t->dow);
....................   RTC_I2C_WRITE(time_t->day);
....................   RTC_I2C_WRITE(time_t->month);
....................   RTC_I2C_WRITE(time_t->year);
....................   RTC_I2C_STOP();
.................... }
.................... 
.................... RTC_Time c_time;
.................... 
.................... // reads time and date
.................... RTC_Time *RTC_Get()
.................... {
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS);
....................   RTC_I2C_WRITE(DS1307_REG_SECONDS);
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01);
....................   c_time.seconds = RTC_I2C_READ(1) & 0x7F;
....................   c_time.minutes = RTC_I2C_READ(1);
....................   c_time.hours   = RTC_I2C_READ(1);
....................   c_time.dow   = RTC_I2C_READ(1);
....................   c_time.day   = RTC_I2C_READ(1);
....................   c_time.month = RTC_I2C_READ(1);
....................   c_time.year  = RTC_I2C_READ(0);
....................   RTC_I2C_STOP();
.................... 
....................   // convert BCD to decimal
....................   c_time.seconds = bcd_to_decimal(c_time.seconds);
....................   c_time.minutes = bcd_to_decimal(c_time.minutes);
....................   c_time.hours   = bcd_to_decimal(c_time.hours);
....................   c_time.day     = bcd_to_decimal(c_time.day);
....................   c_time.month   = bcd_to_decimal(c_time.month);
....................   c_time.year    = bcd_to_decimal(c_time.year);
....................   // end conversion
.................... 
....................   return &c_time;
.................... }
.................... 
.................... // writes 'reg_value' to register of address 'reg_address'
.................... void RTC_Write_Reg(uint8_t reg_address, uint8_t reg_value)
.................... {
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS);
....................   RTC_I2C_WRITE(reg_address);
....................   RTC_I2C_WRITE(reg_value);
....................   RTC_I2C_STOP();
.................... }
.................... 
.................... // returns the value stored in register of address 'reg_address'
.................... uint8_t RTC_Read_Reg(uint8_t reg_address)
.................... {
....................   uint8_t reg_data;
.................... 
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS);
....................   RTC_I2C_WRITE(reg_address);
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS | 0x01);
....................   reg_data = RTC_I2C_READ(0);
....................   RTC_I2C_STOP();
.................... 
....................   return reg_data;
.................... }
.................... 
.................... // sets SQWE pin output
.................... void SQWE_Set(SQWE pin_out)
.................... {
....................   RTC_I2C_START();
....................   RTC_I2C_WRITE(DS1307_ADDRESS);
....................   RTC_I2C_WRITE(DS1307_REG_CONTROL);
....................   RTC_I2C_WRITE(pin_out);
....................   RTC_I2C_STOP();
.................... }
.................... 
.................... // enables RTC oscillator
.................... void OSC_Enable()
.................... {
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS);
....................   sec_reg &= 0x7F;
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg);
.................... }
.................... 
.................... // disables RTC oscillator
.................... void OSC_Disable()
.................... {
....................   uint8_t sec_reg = RTC_Read_Reg(DS1307_REG_SECONDS);
....................   sec_reg |= 0x80;
....................   RTC_Write_Reg(DS1307_REG_SECONDS, sec_reg);
.................... }
.................... 
.................... //////////////////////////////////
.................... #define BTMode input(PIN_B0)
.................... #define BTUp   input(PIN_B1)
.................... #define BTDown input(PIN_B2)
.................... #define BTMal  input(PIN_B3)
.................... #define Relay1  PIN_B4
.................... #define Relay2  PIN_B5
.................... //////////////////////////////////
.................... RTC_Time *mytime;
.................... int8 Mode;
.................... unsigned int8 TempLv, HumiLv;//Nhiet Do, Do Am cai dat
.................... unsigned int8 TempS, HumiS;//Nhiet Do, Do Am tu cam bien
.................... int1 Status = 0;
.................... //////////////////////////////////
.................... #int_ext
.................... _NgatRB()
.................... {  
....................   Mode++;
04CB:  INCF   36,F
....................  lcd_putc('\f');
04CC:  MOVLW  0C
04CD:  MOVWF  5A
04CE:  CALL   195
....................  delay_ms (200);
04CF:  MOVLW  C8
04D0:  MOVWF  5B
04D1:  CALL   057
....................   if (Mode==5)
04D2:  MOVF   36,W
04D3:  SUBLW  05
04D4:  BTFSC  03.2
....................      Mode = 0;
04D5:  CLRF   36
....................   return Mode;
04D6:  MOVF   36,W
04D7:  MOVWF  78
04D8:  BCF    0B.1
04D9:  BCF    0A.3
04DA:  BCF    0A.4
04DB:  GOTO   02B
.................... }
.................... //////////////////////////////////
.................... void _ConRelay(unsigned int8 TempLv, unsigned int8 HumiLv, unsigned int8 TempS, unsigned int8 HumiS);
.................... void _BtMode(int8 Mode);
.................... int16 _ReadADC(unsigned int8 Pin);
.................... int8 _ReadTemp(unsigned int16 GiaTriADC0);
.................... int8 _ReadHumi(unsigned int16 GiaTriADC1);
.................... /////////////////////////////////.
.................... void main()
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2C
1005:  BSF    2C.3
1006:  MOVF   2C,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2C.4
100B:  MOVF   2C,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  09
100F:  MOVWF  13
1010:  MOVLW  28
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    14.7
1015:  BCF    14.6
1016:  BCF    03.5
1017:  BCF    3B.0
1018:  CLRF   3D
1019:  CLRF   3C
101A:  BSF    03.5
101B:  BSF    1F.0
101C:  BSF    1F.1
101D:  BSF    1F.2
101E:  BCF    1F.3
101F:  MOVLW  07
1020:  MOVWF  1C
1021:  BCF    03.7
.................... {  
....................    unsigned int16 GiaTriADC0,GiaTriADC1;
....................    SET_TRIS_A(0xff);
1022:  MOVLW  FF
1023:  MOVWF  05
....................    SET_TRIS_D(0x00);
1024:  MOVLW  00
1025:  MOVWF  08
....................    SET_TRIS_B(0xff);
1026:  MOVLW  FF
1027:  MOVWF  06
....................    //
....................    enable_interrupts(int_ext);
1028:  BCF    03.5
1029:  BSF    0B.4
....................    ext_int_edge(h_to_l);
102A:  BSF    03.5
102B:  BCF    01.6
....................    enable_interrupts(global);
102C:  MOVLW  C0
102D:  BCF    03.5
102E:  IORWF  0B,F
....................    Mode = 0;
102F:  CLRF   36
....................    //
....................    TempLv = read_eeprom(0x02);
1030:  MOVLW  02
1031:  BSF    03.6
1032:  MOVWF  0D
1033:  BSF    03.5
1034:  BCF    0C.7
1035:  BSF    0C.0
1036:  BCF    03.5
1037:  MOVF   0C,W
1038:  BCF    03.6
1039:  MOVWF  37
....................    HumiLv = read_eeprom(0x08);
103A:  MOVLW  08
103B:  BSF    03.6
103C:  MOVWF  0D
103D:  BSF    03.5
103E:  BCF    0C.7
103F:  BSF    0C.0
1040:  BCF    03.5
1041:  MOVF   0C,W
1042:  BCF    03.6
1043:  MOVWF  38
....................    //
....................    setup_adc(ADC_CLOCK_INTERNAL);
1044:  BSF    03.5
1045:  BCF    1F.6
1046:  BCF    03.5
1047:  BSF    1F.6
1048:  BSF    1F.7
1049:  BSF    03.5
104A:  BSF    1F.7
104B:  BCF    03.5
104C:  BSF    1F.0
....................    setup_adc_ports(AN0_AN1_AN2_AN3_AN4);
104D:  BSF    03.5
104E:  BCF    1F.0
104F:  BSF    1F.1
1050:  BCF    1F.2
1051:  BCF    1F.3
....................    //
....................    lcd_init();
1052:  BCF    0A.4
1053:  BCF    03.5
1054:  CALL   59F
1055:  BSF    0A.4
1056:  CLRF   2B
1057:  BTFSC  0B.7
1058:  BSF    2B.7
1059:  BCF    0B.7
....................    lcd_putc('\f');
105A:  MOVLW  0C
105B:  MOVWF  5A
105C:  BCF    0A.4
105D:  CALL   195
105E:  BSF    0A.4
105F:  BTFSC  2B.7
1060:  BSF    0B.7
1061:  CLRF   2B
1062:  BTFSC  0B.7
1063:  BSF    2B.7
1064:  BCF    0B.7
....................    lcd_gotoxy(1,1);
1065:  MOVLW  01
1066:  MOVWF  5B
1067:  MOVWF  5C
1068:  BCF    0A.4
1069:  CALL   06C
106A:  BSF    0A.4
106B:  BTFSC  2B.7
106C:  BSF    0B.7
....................    printf(lcd_putc,"  HE THONG TUOI CAY ");
106D:  MOVLW  DC
106E:  BSF    03.6
106F:  MOVWF  0D
1070:  MOVLW  04
1071:  MOVWF  0F
1072:  BCF    0A.4
1073:  BCF    03.6
1074:  CALL   750
1075:  BSF    0A.4
1076:  CLRF   2B
1077:  BTFSC  0B.7
1078:  BSF    2B.7
1079:  BCF    0B.7
....................    lcd_gotoxy(1,2);
107A:  MOVLW  01
107B:  MOVWF  5B
107C:  MOVLW  02
107D:  MOVWF  5C
107E:  BCF    0A.4
107F:  CALL   06C
1080:  BSF    0A.4
1081:  BTFSC  2B.7
1082:  BSF    0B.7
....................    printf(lcd_putc,"      TU DONG");
1083:  MOVLW  E7
1084:  BSF    03.6
1085:  MOVWF  0D
1086:  MOVLW  04
1087:  MOVWF  0F
1088:  BCF    0A.4
1089:  BCF    03.6
108A:  CALL   750
108B:  BSF    0A.4
....................    delay_ms(5000);
108C:  MOVLW  14
108D:  MOVWF  42
108E:  CLRF   2B
108F:  BTFSC  0B.7
1090:  BSF    2B.7
1091:  BCF    0B.7
1092:  MOVLW  FA
1093:  MOVWF  5B
1094:  BCF    0A.4
1095:  CALL   057
1096:  BSF    0A.4
1097:  BTFSC  2B.7
1098:  BSF    0B.7
1099:  DECFSZ 42,F
109A:  GOTO   08E
109B:  CLRF   2B
109C:  BTFSC  0B.7
109D:  BSF    2B.7
109E:  BCF    0B.7
....................    lcd_putc('\f');
109F:  MOVLW  0C
10A0:  MOVWF  5A
10A1:  BCF    0A.4
10A2:  CALL   195
10A3:  BSF    0A.4
10A4:  BTFSC  2B.7
10A5:  BSF    0B.7
....................  
....................    while(TRUE)
....................    {
....................    
....................       GiaTriADC0 = _ReadADC(0);
10A6:  CLRF   42
10A7:  BCF    0A.4
10A8:  CALL   7B2
10A9:  BSF    0A.4
10AA:  MOVF   79,W
10AB:  MOVWF  3F
10AC:  MOVF   78,W
10AD:  MOVWF  3E
....................       GiaTriADC1 = _ReadADC(1);
10AE:  MOVLW  01
10AF:  MOVWF  42
10B0:  BCF    0A.4
10B1:  CALL   7B2
10B2:  BSF    0A.4
10B3:  MOVF   79,W
10B4:  MOVWF  41
10B5:  MOVF   78,W
10B6:  MOVWF  40
....................       //Nhiet do, Do am tu cam bien
....................       TempS = _ReadTemp(GiaTriADC0);
10B7:  MOVF   3F,W
10B8:  MOVWF  43
10B9:  MOVF   3E,W
10BA:  MOVWF  42
10BB:  BCF    0A.4
10BC:  BSF    0A.3
10BD:  GOTO   000
10BE:  BSF    0A.4
10BF:  BCF    0A.3
10C0:  MOVF   78,W
10C1:  MOVWF  39
....................       HumiS = _ReadHumi(GiaTriADC1);
10C2:  MOVF   41,W
10C3:  MOVWF  43
10C4:  MOVF   40,W
10C5:  MOVWF  42
10C6:  BCF    0A.4
10C7:  BSF    0A.3
10C8:  GOTO   1BE
10C9:  BSF    0A.4
10CA:  BCF    0A.3
10CB:  MOVF   78,W
10CC:  MOVWF  3A
.................... 
....................       switch(Mode)
10CD:  MOVF   36,W
10CE:  ADDLW  FB
10CF:  BTFSC  03.0
10D0:  GOTO   50A
10D1:  ADDLW  05
10D2:  GOTO   50C
....................       {
....................          case 0:  
10D3:  CLRF   2B
10D4:  BTFSC  0B.7
10D5:  BSF    2B.7
10D6:  BCF    0B.7
....................             lcd_gotoxy(1,1);
10D7:  MOVLW  01
10D8:  MOVWF  5B
10D9:  MOVWF  5C
10DA:  BCF    0A.4
10DB:  CALL   06C
10DC:  BSF    0A.4
10DD:  BTFSC  2B.7
10DE:  BSF    0B.7
....................             printf(lcd_putc,"     Setup   Sensor");
10DF:  MOVLW  EE
10E0:  BSF    03.6
10E1:  MOVWF  0D
10E2:  MOVLW  04
10E3:  MOVWF  0F
10E4:  BCF    0A.4
10E5:  BCF    03.6
10E6:  CALL   750
10E7:  BSF    0A.4
10E8:  CLRF   2B
10E9:  BTFSC  0B.7
10EA:  BSF    2B.7
10EB:  BCF    0B.7
....................             lcd_gotoxy(1,2);
10EC:  MOVLW  01
10ED:  MOVWF  5B
10EE:  MOVLW  02
10EF:  MOVWF  5C
10F0:  BCF    0A.4
10F1:  CALL   06C
10F2:  BSF    0A.4
10F3:  BTFSC  2B.7
10F4:  BSF    0B.7
....................             printf(lcd_putc,"Temp: ");
10F5:  MOVLW  F8
10F6:  BSF    03.6
10F7:  MOVWF  0D
10F8:  MOVLW  04
10F9:  MOVWF  0F
10FA:  BCF    0A.4
10FB:  BCF    03.6
10FC:  CALL   750
10FD:  BSF    0A.4
10FE:  CLRF   2B
10FF:  BTFSC  0B.7
1100:  BSF    2B.7
1101:  BCF    0B.7
....................             lcd_gotoxy(1,3);
1102:  MOVLW  01
1103:  MOVWF  5B
1104:  MOVLW  03
1105:  MOVWF  5C
1106:  BCF    0A.4
1107:  CALL   06C
1108:  BSF    0A.4
1109:  BTFSC  2B.7
110A:  BSF    0B.7
....................             printf(lcd_putc,"Humi: ");    
110B:  MOVLW  FC
110C:  BSF    03.6
110D:  MOVWF  0D
110E:  MOVLW  04
110F:  MOVWF  0F
1110:  BCF    0A.4
1111:  BCF    03.6
1112:  CALL   750
1113:  BSF    0A.4
1114:  CLRF   2B
1115:  BTFSC  0B.7
1116:  BSF    2B.7
1117:  BCF    0B.7
....................             lcd_gotoxy(7,2);
1118:  MOVLW  07
1119:  MOVWF  5B
111A:  MOVLW  02
111B:  MOVWF  5C
111C:  BCF    0A.4
111D:  CALL   06C
111E:  BSF    0A.4
111F:  BTFSC  2B.7
1120:  BSF    0B.7
....................             printf(lcd_putc,"%02d",TempLv);
1121:  MOVF   37,W
1122:  MOVWF  42
1123:  MOVLW  01
1124:  MOVWF  43
1125:  BCF    0A.4
1126:  BSF    0A.3
1127:  CALL   26C
1128:  BSF    0A.4
1129:  BCF    0A.3
112A:  CLRF   2B
112B:  BTFSC  0B.7
112C:  BSF    2B.7
112D:  BCF    0B.7
....................             lcd_putc(223);
112E:  MOVLW  DF
112F:  MOVWF  5A
1130:  BCF    0A.4
1131:  CALL   195
1132:  BSF    0A.4
1133:  BTFSC  2B.7
1134:  BSF    0B.7
....................             lcd_putc("C    ");
1135:  MOVLW  00
1136:  BSF    03.6
1137:  MOVWF  0D
1138:  MOVLW  05
1139:  MOVWF  0F
113A:  BCF    0A.4
113B:  BCF    03.6
113C:  CALL   750
113D:  BSF    0A.4
113E:  CLRF   2B
113F:  BTFSC  0B.7
1140:  BSF    2B.7
1141:  BCF    0B.7
....................             lcd_gotoxy(7,3);
1142:  MOVLW  07
1143:  MOVWF  5B
1144:  MOVLW  03
1145:  MOVWF  5C
1146:  BCF    0A.4
1147:  CALL   06C
1148:  BSF    0A.4
1149:  BTFSC  2B.7
114A:  BSF    0B.7
....................             printf(lcd_putc,"%02d",HumiLv);
114B:  MOVF   38,W
114C:  MOVWF  42
114D:  MOVLW  01
114E:  MOVWF  43
114F:  BCF    0A.4
1150:  BSF    0A.3
1151:  CALL   26C
1152:  BSF    0A.4
1153:  BCF    0A.3
....................             lcd_putc("%     ");
1154:  MOVLW  03
1155:  BSF    03.6
1156:  MOVWF  0D
1157:  MOVLW  05
1158:  MOVWF  0F
1159:  BCF    0A.4
115A:  BCF    03.6
115B:  CALL   750
115C:  BSF    0A.4
115D:  CLRF   2B
115E:  BTFSC  0B.7
115F:  BSF    2B.7
1160:  BCF    0B.7
....................             
....................             lcd_gotoxy(15,2);
1161:  MOVLW  0F
1162:  MOVWF  5B
1163:  MOVLW  02
1164:  MOVWF  5C
1165:  BCF    0A.4
1166:  CALL   06C
1167:  BSF    0A.4
1168:  BTFSC  2B.7
1169:  BSF    0B.7
....................             printf(lcd_putc,"%02d",TempS); lcd_putc(223); lcd_putc(67);
116A:  MOVF   39,W
116B:  MOVWF  42
116C:  MOVLW  01
116D:  MOVWF  43
116E:  BCF    0A.4
116F:  BSF    0A.3
1170:  CALL   26C
1171:  BSF    0A.4
1172:  BCF    0A.3
1173:  CLRF   2B
1174:  BTFSC  0B.7
1175:  BSF    2B.7
1176:  BCF    0B.7
1177:  MOVLW  DF
1178:  MOVWF  5A
1179:  BCF    0A.4
117A:  CALL   195
117B:  BSF    0A.4
117C:  BTFSC  2B.7
117D:  BSF    0B.7
117E:  CLRF   2B
117F:  BTFSC  0B.7
1180:  BSF    2B.7
1181:  BCF    0B.7
1182:  MOVLW  43
1183:  MOVWF  5A
1184:  BCF    0A.4
1185:  CALL   195
1186:  BSF    0A.4
1187:  BTFSC  2B.7
1188:  BSF    0B.7
1189:  CLRF   2B
118A:  BTFSC  0B.7
118B:  BSF    2B.7
118C:  BCF    0B.7
....................             lcd_gotoxy(15,3);
118D:  MOVLW  0F
118E:  MOVWF  5B
118F:  MOVLW  03
1190:  MOVWF  5C
1191:  BCF    0A.4
1192:  CALL   06C
1193:  BSF    0A.4
1194:  BTFSC  2B.7
1195:  BSF    0B.7
....................             printf(lcd_putc,"%02d",HumiS); lcd_putc("% ");   
1196:  MOVF   3A,W
1197:  MOVWF  42
1198:  MOVLW  01
1199:  MOVWF  43
119A:  BCF    0A.4
119B:  BSF    0A.3
119C:  CALL   26C
119D:  BSF    0A.4
119E:  BCF    0A.3
119F:  MOVLW  07
11A0:  BSF    03.6
11A1:  MOVWF  0D
11A2:  MOVLW  05
11A3:  MOVWF  0F
11A4:  BCF    0A.4
11A5:  BCF    03.6
11A6:  CALL   750
11A7:  BSF    0A.4
....................             
....................             _ConRelay(TempLv, HumiLv, TempS, HumiS);
11A8:  MOVF   37,W
11A9:  MOVWF  42
11AA:  MOVF   38,W
11AB:  MOVWF  43
11AC:  MOVF   39,W
11AD:  MOVWF  44
11AE:  MOVF   3A,W
11AF:  MOVWF  45
11B0:  BCF    0A.4
11B1:  BSF    0A.3
11B2:  GOTO   2E7
11B3:  BSF    0A.4
11B4:  BCF    0A.3
....................             break;
11B5:  GOTO   50A
.................... 
....................          case 1:
11B6:  CLRF   2B
11B7:  BTFSC  0B.7
11B8:  BSF    2B.7
11B9:  BCF    0B.7
....................             lcd_gotoxy(1,1);
11BA:  MOVLW  01
11BB:  MOVWF  5B
11BC:  MOVWF  5C
11BD:  BCF    0A.4
11BE:  CALL   06C
11BF:  BSF    0A.4
11C0:  BTFSC  2B.7
11C1:  BSF    0B.7
....................             printf(lcd_putc,"                    ");
11C2:  MOVLW  09
11C3:  BSF    03.6
11C4:  MOVWF  0D
11C5:  MOVLW  05
11C6:  MOVWF  0F
11C7:  BCF    0A.4
11C8:  BCF    03.6
11C9:  CALL   750
11CA:  BSF    0A.4
11CB:  CLRF   2B
11CC:  BTFSC  0B.7
11CD:  BSF    2B.7
11CE:  BCF    0B.7
....................             lcd_gotoxy(1,2);
11CF:  MOVLW  01
11D0:  MOVWF  5B
11D1:  MOVLW  02
11D2:  MOVWF  5C
11D3:  BCF    0A.4
11D4:  CALL   06C
11D5:  BSF    0A.4
11D6:  BTFSC  2B.7
11D7:  BSF    0B.7
....................             printf(lcd_putc,"Nhan nut MAL      ");
11D8:  MOVLW  14
11D9:  BSF    03.6
11DA:  MOVWF  0D
11DB:  MOVLW  05
11DC:  MOVWF  0F
11DD:  BCF    0A.4
11DE:  BCF    03.6
11DF:  CALL   750
11E0:  BSF    0A.4
11E1:  CLRF   2B
11E2:  BTFSC  0B.7
11E3:  BSF    2B.7
11E4:  BCF    0B.7
....................             lcd_gotoxy(1,3);
11E5:  MOVLW  01
11E6:  MOVWF  5B
11E7:  MOVLW  03
11E8:  MOVWF  5C
11E9:  BCF    0A.4
11EA:  CALL   06C
11EB:  BSF    0A.4
11EC:  BTFSC  2B.7
11ED:  BSF    0B.7
....................             printf(lcd_putc,"de bat/tat may bom");
11EE:  MOVLW  1E
11EF:  BSF    03.6
11F0:  MOVWF  0D
11F1:  MOVLW  05
11F2:  MOVWF  0F
11F3:  BCF    0A.4
11F4:  BCF    03.6
11F5:  CALL   750
11F6:  BSF    0A.4
....................             if(BTMal == 0)
11F7:  BSF    03.5
11F8:  BSF    06.3
11F9:  BCF    03.5
11FA:  BTFSC  06.3
11FB:  GOTO   245
11FC:  CLRF   2B
11FD:  BTFSC  0B.7
11FE:  BSF    2B.7
11FF:  BCF    0B.7
....................             {
....................                delay_ms(20);
1200:  MOVLW  14
1201:  MOVWF  5B
1202:  BCF    0A.4
1203:  CALL   057
1204:  BSF    0A.4
1205:  BTFSC  2B.7
1206:  BSF    0B.7
....................                while(BTMal == 0);
1207:  BSF    03.5
1208:  BSF    06.3
1209:  BCF    03.5
120A:  BTFSS  06.3
120B:  GOTO   207
....................                if(Status == 1)
120C:  BTFSS  3B.0
120D:  GOTO   22A
....................                {
....................                   Status = 0;              
120E:  BCF    3B.0
....................                   output_high(Relay1);
120F:  BSF    03.5
1210:  BCF    06.4
1211:  BCF    03.5
1212:  BSF    06.4
1213:  CLRF   2B
1214:  BTFSC  0B.7
1215:  BSF    2B.7
1216:  BCF    0B.7
....................                   lcd_gotoxy(1,4);
1217:  MOVLW  01
1218:  MOVWF  5B
1219:  MOVLW  04
121A:  MOVWF  5C
121B:  BCF    0A.4
121C:  CALL   06C
121D:  BSF    0A.4
121E:  BTFSC  2B.7
121F:  BSF    0B.7
....................                   printf(lcd_putc,"May bom bat");
1220:  MOVLW  28
1221:  BSF    03.6
1222:  MOVWF  0D
1223:  MOVLW  05
1224:  MOVWF  0F
1225:  BCF    0A.4
1226:  BCF    03.6
1227:  CALL   750
1228:  BSF    0A.4
....................                }
1229:  GOTO   245
....................                else
....................                {
....................                   Status = 1;
122A:  BSF    3B.0
....................                   output_low(Relay1);
122B:  BSF    03.5
122C:  BCF    06.4
122D:  BCF    03.5
122E:  BCF    06.4
122F:  CLRF   2B
1230:  BTFSC  0B.7
1231:  BSF    2B.7
1232:  BCF    0B.7
....................                   lcd_gotoxy(1,4);
1233:  MOVLW  01
1234:  MOVWF  5B
1235:  MOVLW  04
1236:  MOVWF  5C
1237:  BCF    0A.4
1238:  CALL   06C
1239:  BSF    0A.4
123A:  BTFSC  2B.7
123B:  BSF    0B.7
....................                   printf(lcd_putc,"May bom tat");
123C:  MOVLW  2E
123D:  BSF    03.6
123E:  MOVWF  0D
123F:  MOVLW  05
1240:  MOVWF  0F
1241:  BCF    0A.4
1242:  BCF    03.6
1243:  CALL   750
1244:  BSF    0A.4
....................                }               
....................             }
....................             break; 
1245:  GOTO   50A
....................          case 2:
....................             if(BTUp == 0)
1246:  BSF    03.5
1247:  BSF    06.1
1248:  BCF    03.5
1249:  BTFSC  06.1
124A:  GOTO   264
124B:  CLRF   2B
124C:  BTFSC  0B.7
124D:  BSF    2B.7
124E:  BCF    0B.7
....................             {
....................                delay_ms(20);
124F:  MOVLW  14
1250:  MOVWF  5B
1251:  BCF    0A.4
1252:  CALL   057
1253:  BSF    0A.4
1254:  BTFSC  2B.7
1255:  BSF    0B.7
....................                while(BTUp == 0);
1256:  BSF    03.5
1257:  BSF    06.1
1258:  BCF    03.5
1259:  BTFSS  06.1
125A:  GOTO   256
....................                TempLv = TempLv + 1;
125B:  MOVLW  01
125C:  ADDWF  37,F
....................                if(TempLv>= 100)
125D:  MOVF   37,W
125E:  SUBLW  63
125F:  BTFSC  03.0
1260:  GOTO   263
....................                TempLv = 100;
1261:  MOVLW  64
1262:  MOVWF  37
....................             }
1263:  GOTO   27F
....................             else if(BTDown == 0)
1264:  BSF    03.5
1265:  BSF    06.2
1266:  BCF    03.5
1267:  BTFSC  06.2
1268:  GOTO   27F
1269:  CLRF   2B
126A:  BTFSC  0B.7
126B:  BSF    2B.7
126C:  BCF    0B.7
....................             {
....................                delay_ms(20);
126D:  MOVLW  14
126E:  MOVWF  5B
126F:  BCF    0A.4
1270:  CALL   057
1271:  BSF    0A.4
1272:  BTFSC  2B.7
1273:  BSF    0B.7
....................                while(BTDown == 0);
1274:  BSF    03.5
1275:  BSF    06.2
1276:  BCF    03.5
1277:  BTFSS  06.2
1278:  GOTO   274
....................                TempLv = TempLv - 1;
1279:  MOVLW  01
127A:  SUBWF  37,F
....................                if(TempLv <= 0)
127B:  MOVF   37,F
127C:  BTFSS  03.2
127D:  GOTO   27F
....................                TempLv = 0;
127E:  CLRF   37
....................             }  
....................             
....................             write_eeprom(0x02, TempLv);
127F:  MOVF   0B,W
1280:  MOVWF  77
1281:  BCF    0B.7
1282:  MOVLW  02
1283:  BSF    03.6
1284:  MOVWF  0D
1285:  BCF    03.6
1286:  MOVF   37,W
1287:  BSF    03.6
1288:  MOVWF  0C
1289:  BSF    03.5
128A:  BCF    0C.7
128B:  BSF    0C.2
128C:  MOVLW  55
128D:  MOVWF  0D
128E:  MOVLW  AA
128F:  MOVWF  0D
1290:  BSF    0C.1
1291:  BTFSC  0C.1
1292:  GOTO   291
1293:  BCF    0C.2
1294:  MOVF   77,W
1295:  BCF    03.5
1296:  BCF    03.6
1297:  IORWF  0B,F
1298:  CLRF   2B
1299:  BTFSC  0B.7
129A:  BSF    2B.7
129B:  BCF    0B.7
....................             
....................             lcd_gotoxy(1,1);
129C:  MOVLW  01
129D:  MOVWF  5B
129E:  MOVWF  5C
129F:  BCF    0A.4
12A0:  CALL   06C
12A1:  BSF    0A.4
12A2:  BTFSC  2B.7
12A3:  BSF    0B.7
....................             printf(lcd_putc,"Cai Muc Nhiet Do  ");
12A4:  MOVLW  34
12A5:  BSF    03.6
12A6:  MOVWF  0D
12A7:  MOVLW  05
12A8:  MOVWF  0F
12A9:  BCF    0A.4
12AA:  BCF    03.6
12AB:  CALL   750
12AC:  BSF    0A.4
12AD:  CLRF   2B
12AE:  BTFSC  0B.7
12AF:  BSF    2B.7
12B0:  BCF    0B.7
....................             lcd_gotoxy(1,2);
12B1:  MOVLW  01
12B2:  MOVWF  5B
12B3:  MOVLW  02
12B4:  MOVWF  5C
12B5:  BCF    0A.4
12B6:  CALL   06C
12B7:  BSF    0A.4
12B8:  BTFSC  2B.7
12B9:  BSF    0B.7
....................             printf(lcd_putc,"Temp: %02d",TempLv);
12BA:  MOVLW  3E
12BB:  BSF    03.6
12BC:  MOVWF  0D
12BD:  MOVLW  05
12BE:  MOVWF  0F
12BF:  BCF    03.0
12C0:  MOVLW  06
12C1:  BCF    03.6
12C2:  MOVWF  45
12C3:  BCF    0A.4
12C4:  BSF    0A.3
12C5:  CALL   327
12C6:  BSF    0A.4
12C7:  BCF    0A.3
12C8:  MOVF   37,W
12C9:  MOVWF  42
12CA:  MOVLW  01
12CB:  MOVWF  43
12CC:  BCF    0A.4
12CD:  BSF    0A.3
12CE:  CALL   26C
12CF:  BSF    0A.4
12D0:  BCF    0A.3
12D1:  CLRF   2B
12D2:  BTFSC  0B.7
12D3:  BSF    2B.7
12D4:  BCF    0B.7
....................             lcd_putc(223);
12D5:  MOVLW  DF
12D6:  MOVWF  5A
12D7:  BCF    0A.4
12D8:  CALL   195
12D9:  BSF    0A.4
12DA:  BTFSC  2B.7
12DB:  BSF    0B.7
....................             lcd_putc("C   ");
12DC:  MOVLW  44
12DD:  BSF    03.6
12DE:  MOVWF  0D
12DF:  MOVLW  05
12E0:  MOVWF  0F
12E1:  BCF    0A.4
12E2:  BCF    03.6
12E3:  CALL   750
12E4:  BSF    0A.4
12E5:  CLRF   2B
12E6:  BTFSC  0B.7
12E7:  BSF    2B.7
12E8:  BCF    0B.7
....................             lcd_gotoxy(14,2);
12E9:  MOVLW  0E
12EA:  MOVWF  5B
12EB:  MOVLW  02
12EC:  MOVWF  5C
12ED:  BCF    0A.4
12EE:  CALL   06C
12EF:  BSF    0A.4
12F0:  BTFSC  2B.7
12F1:  BSF    0B.7
....................             printf(lcd_putc,"      ");
12F2:  MOVLW  47
12F3:  BSF    03.6
12F4:  MOVWF  0D
12F5:  MOVLW  05
12F6:  MOVWF  0F
12F7:  BCF    0A.4
12F8:  BCF    03.6
12F9:  CALL   750
12FA:  BSF    0A.4
12FB:  CLRF   2B
12FC:  BTFSC  0B.7
12FD:  BSF    2B.7
12FE:  BCF    0B.7
....................             lcd_gotoxy(1,3);
12FF:  MOVLW  01
1300:  MOVWF  5B
1301:  MOVLW  03
1302:  MOVWF  5C
1303:  BCF    0A.4
1304:  CALL   06C
1305:  BSF    0A.4
1306:  BTFSC  2B.7
1307:  BSF    0B.7
....................             printf(lcd_putc,"                    ");
1308:  MOVLW  4B
1309:  BSF    03.6
130A:  MOVWF  0D
130B:  MOVLW  05
130C:  MOVWF  0F
130D:  BCF    0A.4
130E:  BCF    03.6
130F:  CALL   750
1310:  BSF    0A.4
1311:  CLRF   2B
1312:  BTFSC  0B.7
1313:  BSF    2B.7
1314:  BCF    0B.7
....................             lcd_gotoxy(1,4);
1315:  MOVLW  01
1316:  MOVWF  5B
1317:  MOVLW  04
1318:  MOVWF  5C
1319:  BCF    0A.4
131A:  CALL   06C
131B:  BSF    0A.4
131C:  BTFSC  2B.7
131D:  BSF    0B.7
....................             printf(lcd_putc,"                    ");
131E:  MOVLW  56
131F:  BSF    03.6
1320:  MOVWF  0D
1321:  MOVLW  05
1322:  MOVWF  0F
1323:  BCF    0A.4
1324:  BCF    03.6
1325:  CALL   750
1326:  BSF    0A.4
....................             break;
1327:  GOTO   50A
....................          case 3:
....................             if(BTUp == 0)
1328:  BSF    03.5
1329:  BSF    06.1
132A:  BCF    03.5
132B:  BTFSC  06.1
132C:  GOTO   346
132D:  CLRF   2B
132E:  BTFSC  0B.7
132F:  BSF    2B.7
1330:  BCF    0B.7
....................             {
....................                delay_ms(20);
1331:  MOVLW  14
1332:  MOVWF  5B
1333:  BCF    0A.4
1334:  CALL   057
1335:  BSF    0A.4
1336:  BTFSC  2B.7
1337:  BSF    0B.7
....................                while(BTUp == 0);
1338:  BSF    03.5
1339:  BSF    06.1
133A:  BCF    03.5
133B:  BTFSS  06.1
133C:  GOTO   338
....................                HumiLv = HumiLv + 1;
133D:  MOVLW  01
133E:  ADDWF  38,F
....................                if(HumiLv >= 100)
133F:  MOVF   38,W
1340:  SUBLW  63
1341:  BTFSC  03.0
1342:  GOTO   345
....................                HumiLv = 100;
1343:  MOVLW  64
1344:  MOVWF  38
....................             }
1345:  GOTO   361
....................             else if(BTDown == 0)
1346:  BSF    03.5
1347:  BSF    06.2
1348:  BCF    03.5
1349:  BTFSC  06.2
134A:  GOTO   361
134B:  CLRF   2B
134C:  BTFSC  0B.7
134D:  BSF    2B.7
134E:  BCF    0B.7
....................             {
....................                delay_ms(20);
134F:  MOVLW  14
1350:  MOVWF  5B
1351:  BCF    0A.4
1352:  CALL   057
1353:  BSF    0A.4
1354:  BTFSC  2B.7
1355:  BSF    0B.7
....................                while(BTDown == 0);
1356:  BSF    03.5
1357:  BSF    06.2
1358:  BCF    03.5
1359:  BTFSS  06.2
135A:  GOTO   356
....................                HumiLv = HumiLv - 1;
135B:  MOVLW  01
135C:  SUBWF  38,F
....................                if(HumiLv <= 0)
135D:  MOVF   38,F
135E:  BTFSS  03.2
135F:  GOTO   361
....................                HumiLv = 0;
1360:  CLRF   38
....................             }  
....................             
....................             write_eeprom(0x08, HumiLv);
1361:  MOVF   0B,W
1362:  MOVWF  77
1363:  BCF    0B.7
1364:  MOVLW  08
1365:  BSF    03.6
1366:  MOVWF  0D
1367:  BCF    03.6
1368:  MOVF   38,W
1369:  BSF    03.6
136A:  MOVWF  0C
136B:  BSF    03.5
136C:  BCF    0C.7
136D:  BSF    0C.2
136E:  MOVLW  55
136F:  MOVWF  0D
1370:  MOVLW  AA
1371:  MOVWF  0D
1372:  BSF    0C.1
1373:  BTFSC  0C.1
1374:  GOTO   373
1375:  BCF    0C.2
1376:  MOVF   77,W
1377:  BCF    03.5
1378:  BCF    03.6
1379:  IORWF  0B,F
137A:  CLRF   2B
137B:  BTFSC  0B.7
137C:  BSF    2B.7
137D:  BCF    0B.7
....................             
....................             lcd_gotoxy(1,1);
137E:  MOVLW  01
137F:  MOVWF  5B
1380:  MOVWF  5C
1381:  BCF    0A.4
1382:  CALL   06C
1383:  BSF    0A.4
1384:  BTFSC  2B.7
1385:  BSF    0B.7
....................             printf(lcd_putc,"Cai Muc Do Am      ");
1386:  MOVLW  61
1387:  BSF    03.6
1388:  MOVWF  0D
1389:  MOVLW  05
138A:  MOVWF  0F
138B:  BCF    0A.4
138C:  BCF    03.6
138D:  CALL   750
138E:  BSF    0A.4
138F:  CLRF   2B
1390:  BTFSC  0B.7
1391:  BSF    2B.7
1392:  BCF    0B.7
....................             lcd_gotoxy(1,2);
1393:  MOVLW  01
1394:  MOVWF  5B
1395:  MOVLW  02
1396:  MOVWF  5C
1397:  BCF    0A.4
1398:  CALL   06C
1399:  BSF    0A.4
139A:  BTFSC  2B.7
139B:  BSF    0B.7
....................             printf(lcd_putc,"Humi: %02d",HumiLv);
139C:  MOVLW  6B
139D:  BSF    03.6
139E:  MOVWF  0D
139F:  MOVLW  05
13A0:  MOVWF  0F
13A1:  BCF    03.0
13A2:  MOVLW  06
13A3:  BCF    03.6
13A4:  MOVWF  45
13A5:  BCF    0A.4
13A6:  BSF    0A.3
13A7:  CALL   327
13A8:  BSF    0A.4
13A9:  BCF    0A.3
13AA:  MOVF   38,W
13AB:  MOVWF  42
13AC:  MOVLW  01
13AD:  MOVWF  43
13AE:  BCF    0A.4
13AF:  BSF    0A.3
13B0:  CALL   26C
13B1:  BSF    0A.4
13B2:  BCF    0A.3
....................             lcd_putc("% ");
13B3:  MOVLW  71
13B4:  BSF    03.6
13B5:  MOVWF  0D
13B6:  MOVLW  05
13B7:  MOVWF  0F
13B8:  BCF    0A.4
13B9:  BCF    03.6
13BA:  CALL   750
13BB:  BSF    0A.4
....................             break;
13BC:  GOTO   50A
....................           case 4:
....................           
....................  delay_ms(500);
13BD:  MOVLW  02
13BE:  MOVWF  42
13BF:  CLRF   2B
13C0:  BTFSC  0B.7
13C1:  BSF    2B.7
13C2:  BCF    0B.7
13C3:  MOVLW  FA
13C4:  MOVWF  5B
13C5:  BCF    0A.4
13C6:  CALL   057
13C7:  BSF    0A.4
13C8:  BTFSC  2B.7
13C9:  BSF    0B.7
13CA:  DECFSZ 42,F
13CB:  GOTO   3BF
....................   mytime->hours   = 8;
13CC:  MOVLW  02
13CD:  ADDWF  34,W
13CE:  MOVWF  04
13CF:  BCF    03.7
13D0:  BTFSC  35.0
13D1:  BSF    03.7
13D2:  MOVLW  08
13D3:  MOVWF  00
....................   mytime->minutes = 30;
13D4:  MOVLW  01
13D5:  ADDWF  34,W
13D6:  MOVWF  04
13D7:  BCF    03.7
13D8:  BTFSC  35.0
13D9:  BSF    03.7
13DA:  MOVLW  1E
13DB:  MOVWF  00
....................   mytime->seconds = 50;
13DC:  MOVF   34,W
13DD:  MOVWF  04
13DE:  BCF    03.7
13DF:  BTFSC  35.0
13E0:  BSF    03.7
13E1:  MOVLW  32
13E2:  MOVWF  00
....................   mytime->day   = 1;
13E3:  MOVLW  04
13E4:  ADDWF  34,W
13E5:  MOVWF  04
13E6:  BCF    03.7
13E7:  BTFSC  35.0
13E8:  BSF    03.7
13E9:  MOVLW  01
13EA:  MOVWF  00
....................   mytime->month = 6;
13EB:  MOVLW  05
13EC:  ADDWF  34,W
13ED:  MOVWF  04
13EE:  BCF    03.7
13EF:  BTFSC  35.0
13F0:  BSF    03.7
13F1:  MOVLW  06
13F2:  MOVWF  00
....................   mytime->year  = 2022;
13F3:  ADDWF  34,W
13F4:  MOVWF  04
13F5:  BCF    03.7
13F6:  BTFSC  35.0
13F7:  BSF    03.7
13F8:  MOVLW  E6
13F9:  MOVWF  00
....................            lcd_init();
13FA:  BCF    0A.4
13FB:  CALL   59F
13FC:  BSF    0A.4
13FD:  CLRF   2B
13FE:  BTFSC  0B.7
13FF:  BSF    2B.7
1400:  BCF    0B.7
....................             lcd_putc('\f');
1401:  MOVLW  0C
1402:  MOVWF  5A
1403:  BCF    0A.4
1404:  CALL   195
1405:  BSF    0A.4
1406:  BTFSC  2B.7
1407:  BSF    0B.7
1408:  CLRF   2B
1409:  BTFSC  0B.7
140A:  BSF    2B.7
140B:  BCF    0B.7
....................     // print them
....................       lcd_gotoxy(1, 1);
140C:  MOVLW  01
140D:  MOVWF  5B
140E:  MOVWF  5C
140F:  BCF    0A.4
1410:  CALL   06C
1411:  BSF    0A.4
1412:  BTFSC  2B.7
1413:  BSF    0B.7
....................       printf(lcd_putc, "TIME: %02u:%02u:%02u", mytime->hours, mytime->minutes, mytime->seconds); 
1414:  MOVLW  02
1415:  ADDWF  34,W
1416:  MOVWF  04
1417:  BCF    03.7
1418:  BTFSC  35.0
1419:  BSF    03.7
141A:  MOVF   00,W
141B:  MOVWF  42
141C:  MOVLW  01
141D:  ADDWF  34,W
141E:  MOVWF  04
141F:  BCF    03.7
1420:  BTFSC  35.0
1421:  BSF    03.7
1422:  MOVF   00,W
1423:  MOVWF  43
1424:  MOVF   34,W
1425:  MOVWF  04
1426:  BCF    03.7
1427:  BTFSC  35.0
1428:  BSF    03.7
1429:  MOVF   00,W
142A:  MOVWF  44
142B:  MOVLW  73
142C:  BSF    03.6
142D:  MOVWF  0D
142E:  MOVLW  05
142F:  MOVWF  0F
1430:  BCF    03.0
1431:  MOVLW  06
1432:  BCF    03.6
1433:  MOVWF  45
1434:  BCF    0A.4
1435:  BSF    0A.3
1436:  CALL   327
1437:  BSF    0A.4
1438:  BCF    0A.3
1439:  MOVF   42,W
143A:  MOVWF  45
143B:  MOVLW  01
143C:  MOVWF  46
143D:  BCF    0A.4
143E:  BSF    0A.3
143F:  CALL   38E
1440:  BSF    0A.4
1441:  BCF    0A.3
1442:  CLRF   2B
1443:  BTFSC  0B.7
1444:  BSF    2B.7
1445:  BCF    0B.7
1446:  MOVLW  3A
1447:  MOVWF  5A
1448:  BCF    0A.4
1449:  CALL   195
144A:  BSF    0A.4
144B:  BTFSC  2B.7
144C:  BSF    0B.7
144D:  MOVF   43,W
144E:  MOVWF  45
144F:  MOVLW  01
1450:  MOVWF  46
1451:  BCF    0A.4
1452:  BSF    0A.3
1453:  CALL   38E
1454:  BSF    0A.4
1455:  BCF    0A.3
1456:  CLRF   2B
1457:  BTFSC  0B.7
1458:  BSF    2B.7
1459:  BCF    0B.7
145A:  MOVLW  3A
145B:  MOVWF  5A
145C:  BCF    0A.4
145D:  CALL   195
145E:  BSF    0A.4
145F:  BTFSC  2B.7
1460:  BSF    0B.7
1461:  MOVF   44,W
1462:  MOVWF  45
1463:  MOVLW  01
1464:  MOVWF  46
1465:  BCF    0A.4
1466:  BSF    0A.3
1467:  CALL   38E
1468:  BSF    0A.4
1469:  BCF    0A.3
146A:  CLRF   2B
146B:  BTFSC  0B.7
146C:  BSF    2B.7
146D:  BCF    0B.7
....................       lcd_gotoxy(1, 2);
146E:  MOVLW  01
146F:  MOVWF  5B
1470:  MOVLW  02
1471:  MOVWF  5C
1472:  BCF    0A.4
1473:  CALL   06C
1474:  BSF    0A.4
1475:  BTFSC  2B.7
1476:  BSF    0B.7
....................       printf(lcd_putc, "DATE: %02u/%02u/20%02u", mytime->day, mytime->month, mytime->year);
1477:  MOVLW  04
1478:  ADDWF  34,W
1479:  MOVWF  04
147A:  BCF    03.7
147B:  BTFSC  35.0
147C:  BSF    03.7
147D:  MOVF   00,W
147E:  MOVWF  42
147F:  MOVLW  05
1480:  ADDWF  34,W
1481:  MOVWF  04
1482:  BCF    03.7
1483:  BTFSC  35.0
1484:  BSF    03.7
1485:  MOVF   00,W
1486:  MOVWF  43
1487:  MOVLW  06
1488:  ADDWF  34,W
1489:  MOVWF  04
148A:  BCF    03.7
148B:  BTFSC  35.0
148C:  BSF    03.7
148D:  MOVF   00,W
148E:  MOVWF  44
148F:  MOVLW  7E
1490:  BSF    03.6
1491:  MOVWF  0D
1492:  MOVLW  05
1493:  MOVWF  0F
1494:  BCF    03.0
1495:  MOVLW  06
1496:  BCF    03.6
1497:  MOVWF  45
1498:  BCF    0A.4
1499:  BSF    0A.3
149A:  CALL   327
149B:  BSF    0A.4
149C:  BCF    0A.3
149D:  MOVF   42,W
149E:  MOVWF  45
149F:  MOVLW  01
14A0:  MOVWF  46
14A1:  BCF    0A.4
14A2:  BSF    0A.3
14A3:  CALL   38E
14A4:  BSF    0A.4
14A5:  BCF    0A.3
14A6:  CLRF   2B
14A7:  BTFSC  0B.7
14A8:  BSF    2B.7
14A9:  BCF    0B.7
14AA:  MOVLW  2F
14AB:  MOVWF  5A
14AC:  BCF    0A.4
14AD:  CALL   195
14AE:  BSF    0A.4
14AF:  BTFSC  2B.7
14B0:  BSF    0B.7
14B1:  MOVF   43,W
14B2:  MOVWF  45
14B3:  MOVLW  01
14B4:  MOVWF  46
14B5:  BCF    0A.4
14B6:  BSF    0A.3
14B7:  CALL   38E
14B8:  BSF    0A.4
14B9:  BCF    0A.3
14BA:  CLRF   2B
14BB:  BTFSC  0B.7
14BC:  BSF    2B.7
14BD:  BCF    0B.7
14BE:  MOVLW  2F
14BF:  MOVWF  5A
14C0:  BCF    0A.4
14C1:  CALL   195
14C2:  BSF    0A.4
14C3:  BTFSC  2B.7
14C4:  BSF    0B.7
14C5:  CLRF   2B
14C6:  BTFSC  0B.7
14C7:  BSF    2B.7
14C8:  BCF    0B.7
14C9:  MOVLW  32
14CA:  MOVWF  5A
14CB:  BCF    0A.4
14CC:  CALL   195
14CD:  BSF    0A.4
14CE:  BTFSC  2B.7
14CF:  BSF    0B.7
14D0:  CLRF   2B
14D1:  BTFSC  0B.7
14D2:  BSF    2B.7
14D3:  BCF    0B.7
14D4:  MOVLW  30
14D5:  MOVWF  5A
14D6:  BCF    0A.4
14D7:  CALL   195
14D8:  BSF    0A.4
14D9:  BTFSC  2B.7
14DA:  BSF    0B.7
14DB:  MOVF   44,W
14DC:  MOVWF  45
14DD:  MOVLW  01
14DE:  MOVWF  46
14DF:  BCF    0A.4
14E0:  BSF    0A.3
14E1:  CALL   38E
14E2:  BSF    0A.4
14E3:  BCF    0A.3
14E4:  CLRF   2B
14E5:  BTFSC  0B.7
14E6:  BSF    2B.7
14E7:  BCF    0B.7
....................       lcd_gotoxy(1,3);          
14E8:  MOVLW  01
14E9:  MOVWF  5B
14EA:  MOVLW  03
14EB:  MOVWF  5C
14EC:  BCF    0A.4
14ED:  CALL   06C
14EE:  BSF    0A.4
14EF:  BTFSC  2B.7
14F0:  BSF    0B.7
....................       printf(lcd_putc,"Mal de tat/mo den"); 
14F1:  MOVLW  8A
14F2:  BSF    03.6
14F3:  MOVWF  0D
14F4:  MOVLW  05
14F5:  MOVWF  0F
14F6:  BCF    0A.4
14F7:  BCF    03.6
14F8:  CALL   750
14F9:  BSF    0A.4
....................       delay_ms(500);
14FA:  MOVLW  02
14FB:  MOVWF  42
14FC:  CLRF   2B
14FD:  BTFSC  0B.7
14FE:  BSF    2B.7
14FF:  BCF    0B.7
1500:  MOVLW  FA
1501:  MOVWF  5B
1502:  BCF    0A.4
1503:  CALL   057
1504:  BSF    0A.4
1505:  BTFSC  2B.7
1506:  BSF    0B.7
1507:  DECFSZ 42,F
1508:  GOTO   4FC
....................       break;
1509:  GOTO   50A
....................   
....................       }
150A:  GOTO   0A6
....................    }
.................... }
.................... 
150B:  SLEEP
.................... void _ConRelay(unsigned int8 TempLv, unsigned int8 HumiLv, unsigned int8 , unsigned int8 HumiS)
.................... {
....................    if (TempS >= TempLv || HumiS <= HumiLv)
*
0AE7:  MOVF   42,W
0AE8:  SUBWF  44,W
0AE9:  BTFSC  03.0
0AEA:  GOTO   2EF
0AEB:  MOVF   45,W
0AEC:  SUBWF  43,W
0AED:  BTFSS  03.0
0AEE:  GOTO   30A
....................    {
....................       output_high(Relay1);
0AEF:  BSF    03.5
0AF0:  BCF    06.4
0AF1:  BCF    03.5
0AF2:  BSF    06.4
0AF3:  CLRF   2B
0AF4:  BTFSC  0B.7
0AF5:  BSF    2B.7
0AF6:  BCF    0B.7
....................       lcd_gotoxy(1,4);
0AF7:  MOVLW  01
0AF8:  MOVWF  5B
0AF9:  MOVLW  04
0AFA:  MOVWF  5C
0AFB:  BCF    0A.3
0AFC:  CALL   06C
0AFD:  BSF    0A.3
0AFE:  BTFSC  2B.7
0AFF:  BSF    0B.7
....................       printf(lcd_putc,"May bom bat");
0B00:  MOVLW  93
0B01:  BSF    03.6
0B02:  MOVWF  0D
0B03:  MOVLW  05
0B04:  MOVWF  0F
0B05:  BCF    0A.3
0B06:  BCF    03.6
0B07:  CALL   750
0B08:  BSF    0A.3
....................    }
0B09:  GOTO   324
....................    else
....................    {
....................       output_low(Relay1);
0B0A:  BSF    03.5
0B0B:  BCF    06.4
0B0C:  BCF    03.5
0B0D:  BCF    06.4
0B0E:  CLRF   2B
0B0F:  BTFSC  0B.7
0B10:  BSF    2B.7
0B11:  BCF    0B.7
....................       lcd_gotoxy(1,4);
0B12:  MOVLW  01
0B13:  MOVWF  5B
0B14:  MOVLW  04
0B15:  MOVWF  5C
0B16:  BCF    0A.3
0B17:  CALL   06C
0B18:  BSF    0A.3
0B19:  BTFSC  2B.7
0B1A:  BSF    0B.7
....................       printf(lcd_putc,"May bom tat");
0B1B:  MOVLW  99
0B1C:  BSF    03.6
0B1D:  MOVWF  0D
0B1E:  MOVLW  05
0B1F:  MOVWF  0F
0B20:  BCF    0A.3
0B21:  BCF    03.6
0B22:  CALL   750
0B23:  BSF    0A.3
....................    }
0B24:  BCF    0A.3
0B25:  BSF    0A.4
0B26:  GOTO   50A (RETURN)
.................... }
.................... 
.................... int16 _ReadADC(unsigned int8 Pin)
.................... {
....................    set_adc_channel(Pin);
*
07B2:  RLF    42,W
07B3:  MOVWF  77
07B4:  RLF    77,F
07B5:  RLF    77,F
07B6:  MOVLW  F8
07B7:  ANDWF  77,F
07B8:  MOVF   1F,W
07B9:  ANDLW  C7
07BA:  IORWF  77,W
07BB:  MOVWF  1F
....................    unsigned int16 Value = read_adc();
07BC:  BSF    1F.2
07BD:  BTFSC  1F.2
07BE:  GOTO   7BD
07BF:  MOVF   1E,W
07C0:  MOVWF  79
07C1:  BSF    03.5
07C2:  MOVF   1E,W
07C3:  MOVWF  78
07C4:  MOVF   79,W
07C5:  BCF    03.5
07C6:  MOVWF  44
07C7:  MOVF   78,W
07C8:  MOVWF  43
....................    return Value;
07C9:  MOVF   43,W
07CA:  MOVWF  78
07CB:  MOVF   44,W
07CC:  MOVWF  79
07CD:  RETURN
.................... }
.................... 
.................... int8 _ReadTemp(unsigned int16 GiaTriADC0)
*
0800:  MOVF   43,W
0801:  MOVWF  49
0802:  MOVF   42,W
0803:  MOVWF  48
*
0820:  MOVF   7A,W
0821:  MOVWF  4B
0822:  MOVF   79,W
0823:  MOVWF  4A
0824:  MOVF   78,W
0825:  MOVWF  49
0826:  MOVF   77,W
0827:  MOVWF  48
0828:  MOVF   4B,W
0829:  MOVWF  4F
082A:  MOVF   4A,W
082B:  MOVWF  4E
082C:  MOVF   49,W
082D:  MOVWF  4D
082E:  MOVF   48,W
082F:  MOVWF  4C
0830:  CLRF   53
0831:  CLRF   52
0832:  MOVLW  7A
0833:  MOVWF  51
0834:  MOVLW  87
0835:  MOVWF  50
*
08AB:  MOVF   7A,W
08AC:  MOVWF  4B
08AD:  MOVF   79,W
08AE:  MOVWF  4A
08AF:  MOVF   78,W
08B0:  MOVWF  49
08B1:  MOVF   77,W
08B2:  MOVWF  48
08B3:  MOVF   4B,W
08B4:  MOVWF  4F
08B5:  MOVF   4A,W
08B6:  MOVWF  4E
08B7:  MOVF   49,W
08B8:  MOVWF  4D
08B9:  MOVF   48,W
08BA:  MOVWF  4C
08BB:  CLRF   53
08BC:  MOVLW  C0
08BD:  MOVWF  52
08BE:  MOVLW  7F
08BF:  MOVWF  51
08C0:  MOVLW  88
08C1:  MOVWF  50
*
098C:  MOVF   7A,W
098D:  MOVWF  47
098E:  MOVF   79,W
098F:  MOVWF  46
0990:  MOVF   78,W
0991:  MOVWF  45
0992:  MOVF   77,W
0993:  MOVWF  44
.................... {
....................    float DienAp = ((float)GiaTriADC0 * 500)/1023.0f;
....................    return (int8)DienAp;
0994:  MOVF   47,W
0995:  MOVWF  4B
0996:  MOVF   46,W
0997:  MOVWF  4A
0998:  MOVF   45,W
0999:  MOVWF  49
099A:  MOVF   44,W
099B:  MOVWF  48
*
09BA:  MOVF   78,W
09BB:  BCF    0A.3
09BC:  BSF    0A.4
09BD:  GOTO   0BE (RETURN)
....................    /*LM35
....................       datasheet:
....................       10mv                   -->      1 C
....................       (5000*GiaTriADC)/1023  -->      y
....................       => y = ((5000*GiaTriADC)/1023)/10 = (500*GiaTriADC)/1023*/
.................... }
.................... 
.................... int8 _ReadHumi(unsigned int16 GiaTriADC1)
.................... {
....................    unsigned int32 Value;
....................    Value = ((int32)GiaTriADC1*100)/1023;
09BE:  CLRF   4B
09BF:  CLRF   4A
09C0:  MOVF   43,W
09C1:  MOVWF  49
09C2:  MOVF   42,W
09C3:  MOVWF  48
09C4:  MOVF   4B,W
09C5:  MOVWF  4F
09C6:  MOVF   4A,W
09C7:  MOVWF  4E
09C8:  MOVF   49,W
09C9:  MOVWF  4D
09CA:  MOVF   48,W
09CB:  MOVWF  4C
09CC:  CLRF   53
09CD:  CLRF   52
09CE:  CLRF   51
09CF:  MOVLW  64
09D0:  MOVWF  50
*
09FA:  MOVF   7A,W
09FB:  MOVWF  4B
09FC:  MOVF   79,W
09FD:  MOVWF  4A
09FE:  MOVF   78,W
09FF:  MOVWF  49
0A00:  MOVF   77,W
0A01:  MOVWF  48
0A02:  BCF    03.1
0A03:  MOVF   4B,W
0A04:  MOVWF  4F
0A05:  MOVF   4A,W
0A06:  MOVWF  4E
0A07:  MOVF   49,W
0A08:  MOVWF  4D
0A09:  MOVF   48,W
0A0A:  MOVWF  4C
0A0B:  CLRF   53
0A0C:  CLRF   52
0A0D:  MOVLW  03
0A0E:  MOVWF  51
0A0F:  MOVLW  FF
0A10:  MOVWF  50
*
0A5F:  MOVF   7A,W
0A60:  MOVWF  47
0A61:  MOVF   79,W
0A62:  MOVWF  46
0A63:  MOVF   78,W
0A64:  MOVWF  45
0A65:  MOVF   77,W
0A66:  MOVWF  44
....................    return (int8)Value;
0A67:  MOVF   44,W
0A68:  MOVWF  78
0A69:  BCF    0A.3
0A6A:  BSF    0A.4
0A6B:  GOTO   0C9 (RETURN)
.................... }
.................... 

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
